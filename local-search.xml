<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>npm与包</title>
    <link href="/2023/03/10/node-npm/"/>
    <url>/2023/03/10/node-npm/</url>
    
    <content type="html"><![CDATA[<h1 id="npm与包"><a href="#npm与包" class="headerlink" title="npm与包"></a>npm与包</h1><p>1、包</p><ol><li><p>什么是包</p><p> Node.js中的第三方模块又叫做包。<br> 就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同</p></li><li><p>包的来源</p><p> 不同于Node.js中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用</p><p> 注意：Node.js中的包都是免费且开源的，不需要付费即可免费下载使用</p></li><li><p>为什么需要包</p><p> 由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时候，效率很低。</p><p> 包是基于内置模块分装出来的，提供了更高级、更方便的API，极大的提高了开发效率</p><p> 包和内置模块之间的关系，类似于jQuery和浏览器内置API之间的关系</p></li><li><p>从哪里下载包</p><p> 国外有一家IT公司，叫做npm，Inc，这家公司旗下有一个非常著名的网站：<a href="https://www.npmjs.com/">npm</a>，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！</p><p> 到目前位置，全球约1100多万的开发人员，通过这个包共享平台，开发共享了超过120多万个包供我们使用</p><p> npm，Inc。公司提供了一个地址为<a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需的包</p><p> 注意：</p><pre><code class="hljs"> 从https://www.npmjs.com/ 网站上搜索自己所需要的包 从https://registry.npmjs.org/ 服务器上下载自己需要的包</code></pre></li><li><p>如何下载包</p><p> npm,Inc公司提供了一个包管理工具，我们可以使用这个包管理工具，从<a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器把需要的包下载到本地</p><p> 这个包管理工具的名字叫做Node Package Manager(简称npm包管理工具)，这个包管理工具随着Node.js的安装包一起被安装到了用户的电脑上</p><p> 大家可以在终端中执行npm -v命令，来查看自己电脑上所安装的npm包管理工具的版本号；</p></li></ol><p>2、npm初体验</p><ol><li><p>格式化时间的传统做法(具体看14.dataFormat.js~15.test.js)</p><ol><li>创建格式化时间的自定义模块</li><li>定义格式化时间的方法</li><li>创建补零函数</li><li>从自定义模块中导入格式化时间的函数</li><li>导入格式化时间的自定义模块</li><li>调用格式化时间的函数</li></ol></li><li><p>格式化时间的高级做法</p><ol><li>使用npm包管理工具，在项目中安装格式化时间的包moment</li><li>使用require()导入格式化时间的包</li><li>参考moment的官方API文档对时间进行格式化</li></ol></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 导入moment包<br><br>const moment=require(<span class="hljs-string">&#x27;moment&#x27;</span>);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 参考moment官方API文件，调用对应的方法，对时间进行格式化<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2.1</span>调用moment()方法，得到当前的时间<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2.2</span> 针对当前的时间，调用format()方法，按照指定的格式进行时间的格式化<br><br>const dt=moment().format(<span class="hljs-string">&#x27;YYY-MM-DD HH:mm:ss&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li><p>在项目中安装包的命令</p><p> 如果想在项目中安装指定名称的包，需要运行如下的命令：</p><pre><code class="hljs"> npm install 包的完整名称</code></pre><p> 上述的装包命令，可以简写成如下格式：</p><pre><code class="hljs"> npm i 完整的包名称</code></pre></li><li><p>初次装包后多了那些文件</p><p> 初次装包完成后，在项目中文件夹下多一个叫做node_modules的文件夹和package-lock.json的配置文件</p><p> 其中：</p><p> node_modules文件夹用来存放所有已安装到项目中的包，require()导入第三方包时，就是从这个目录中查找并加载包</p><p> package-lock.json配置文件用来记录node_modules目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</p><p> 注意：程序员不要手动修改node_modules或package-lock.join文件中任何代码，npm包管理工具会自动维护它们</p></li><li><p>安装指定版本的包</p><p> 默认情况下，使用npm install命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过@符号指定具体的版本，例如：</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> i moment@<span class="hljs-number">2</span>.<span class="hljs-number">22</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ol start="6"><li><p>包的语义化版本规范</p><p> 包的版本号是以‘点分十进制’形式进行定义的，总共有三位数字，例如2.24.0</p><p> 其中每一位数字所代表的含义如下：</p><pre><code class="hljs"> 第一位数字：大版本 第二位数字：功能版本 第三位数字：Bug修复版本 版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零</code></pre></li></ol><p>3、包管理配置文件</p><pre><code class="hljs">npm规定，在项目根目录中，必须提供一个叫做package.json的包管理配置文件，用来记录与项目有关的一些配置信息。例如    项目的名称、版本号、描述等    项目中都用到了哪些包    哪些包在开发和部署时都需要用到</code></pre><ol><li><p>多人协作的问题</p><p> 遇到的问题：第三方包的体积过大，不方便团队成员之间共享项目源代码</p><p> 解决方案：共享时剔除node_modules</p></li><li><p>如何记录项目中安装了哪些包</p><p> 在项目根目录中，创建一个叫做package.json的配置文件，即可用来记录项目中安装哪些包。从而方便剔除node_modules目录之后，在团队成员之间共享项目的源代码</p><p> 注意：今后项目开发中，一定要把node_modules文件夹，添加到.gitignore忽略文件中</p></li><li><p>快速创建package.json</p><p> npm包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建package.json这个包管理配置文件：</p><pre><code class="hljs"> //作用：在执行命令所处的目录中，快速新建package.json文件 npm init -y</code></pre><p> 注意：</p><ol><li>上述命令只能在英文的目录中成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格</li><li>运行npm install命令安装包的时候，npm包管理工具自动把包的名称和版本号，记录到package.json中</li></ol></li><li><p>dependencies节点</p><p> package.json文件中，有一个dependencies节点，专门来记录您使用npm install命令安装了哪些包。</p></li><li><p>一次性安装所有的包</p><p> 当我们拿到一个剔除了node_modules的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>由于项目运行依赖于moment这个包，如果没有提前安装好这个包，就会报如下的错误：<br>  <br>    Error:Cannot find module <span class="hljs-string">&#x27;moment&#x27;</span>;<br><br>可以运行npm install命令(或npm i)一次性安装所有的依赖包：<br><br> <span class="hljs-regexp">//</span>执行npm install命令时，npm包管理工具会先读取package.json中的dependencies节点，<br><br> <span class="hljs-regexp">//</span>读取到已记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包一次性下载到项目中<br><br>    npm install<br></code></pre></td></tr></table></figure><ol start="6"><li><p>卸载包</p><p> 可以运行npm uninstall命令，来卸载指定的包：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall moment<br></code></pre></td></tr></table></figure><pre><code class="hljs">    注意：npm uninstall命令执行成功后，会把卸载的包，自动从package.json的dependencies中移除掉</code></pre><ol start="7"><li><p>devDependencies节点</p><p> 如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies节点中</p><p> 与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中</p><p> 您可以使用如下的命令，将包记录到devDependencies节点中：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 安装指定的包，并记录到devDependencies节点中<br>npm i 包名 -D<br></code></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//注意：上述命令是简写形式，等价于下面完整的写法：</span><br>npm install 包名 --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>4、解决下包速度慢的问题</p><ol><li><p>为什么下包速度慢</p><p> 在使用npm下包的时候，默认从外国的<a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢</p><p> <a href="https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%E7%BC%86/4107830">https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%E7%BC%86/4107830</a><br> <a href="https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%BA%95%E5%85%89%E7%BC%86/10520363">https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%BA%95%E5%85%89%E7%BC%86/10520363</a><br> <a href="https://baike.baidu.com/item/APG/2364772?fr=aladdin">https://baike.baidu.com/item/APG/2364772?fr=aladdin</a></p></li><li><p>淘宝NPM镜像服务器</p><p> 淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后再国内提供下包的服务。从而极大的提高了下包的速度</p><p> 扩展：</p><pre><code class="hljs"> 镜像(Mirroring)是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像</code></pre></li><li><p>切换npm的下包镜像源</p><p> 下包的镜像源，指的就是下包的服务器地址。</p></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#查看当前的下包镜像源</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">get</span> registry<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br><span class="hljs-comment">#将下包的镜像源切换为淘宝镜像源</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> <span class="hljs-attribute">registry</span>=https://registry.npm.taobao.org/<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#检查镜像源是否下载成功</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">get</span> registry<br></code></pre></td></tr></table></figure><ol start="4"><li><p>nrm</p><p> 为了更方便的切换下包的镜像源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#通过npm包管理器，将nrm安装为全局可用的工具</span><br>npm i nrm -g<br><span class="hljs-comment">#查看所有可用的镜像源</span><br>nrm <span class="hljs-built_in">ls</span><br><span class="hljs-comment">#将下包的镜像源切换为taobao镜像</span><br>nrm use taobao<br></code></pre></td></tr></table></figure><p>5、包的分类</p><pre><code class="hljs">使用npm包管理工具下载的包，共分为两大类，分别是：项目包全局包</code></pre><ol><li><p>项目包</p><p> 那些被安装到项目的node_modules目录中的包，都是项目包</p><p> 项目包又分为两类，分别是：</p><p> 开发依赖包(被记录到devDependencies节点中的包，只在开发期间会用到)<br> 核心依赖包(被记录到dependencies节点中的包，在开发期间和项目上线之后都会用)</p></li><li><p>全局包</p><p> 在执行npm install命令时，如果提供了-g参数，则会把包安装为全局包。<br> 全局包会被安装到C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i 包名 -g           <span class="hljs-comment">#全局包安装指定的包</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall 包名 -g   <span class="hljs-comment">#卸载全局安装的包</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">注意：1. 只有工具性质的包，才有全局安装的必要性，因为它们提供了好用的终端命令2. 判断某个包是否需要全局安装后才能使用，可以参考官网提供的使用说明即可</code></pre><ol start="3"><li><p>i5ting_toc</p><p> i5ting_toc是一个可以把md文档转为html页面的小工具，使用步骤如下：</p></li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#将i5ting_toc安装为全局包</span><br>npm <span class="hljs-keyword">install</span> -g i5ting_toc<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#调用i5ting_toc，轻松实现md转html的功能</span><br>i5ting_toc <span class="hljs-operator">-f</span> 要转换的<span class="hljs-built_in">md</span>文件路径 <span class="hljs-literal">-o</span><br></code></pre></td></tr></table></figure><p>6、规范的包结构</p><pre><code class="hljs">在清楚了包的概念，以及如何下载和使用之后，接下来，我们深入了解一下包的内部结构一个规范的包，它的组成结构必须符合以下3点要求1. 包必须以单独的目录而存在2. 包的顶级目录下必须包含package.json这个包管理配置文件3. package.json中必须包含name,version,main这三个属性，分别代表包的名字、版本号、包的入口。注意：以上3点要求是一个规范的包结构遵循的格式，关于更多的约束，可以参考如下网址：https://yarnpkg.com/zh-Hans/docs/package-json</code></pre><p>7、开发属于自己的包</p><ol><li><p>需要实现的功能</p><ol><li>格式化日期</li><li>转义HTML中的特殊字符&#x2F;&#x2F;用到.htmlEscape()方法</li><li>还原HTML中的特殊字符&#x2F;&#x2F;用到htmlUnEscape()方法</li></ol></li><li><p>初始化包的基本结构</p><ol><li><p>新键itheima-tools文件夹，作为包的根目录</p></li><li><p>在itheima-tools文件夹中，新增如下三个文件：</p><p> package.json(包管理配置文件)<br> index.js(包的入口文件)<br> README.md(包的说明文档)</p></li></ol></li><li><p>初始化package.json</p></li><li><p>在index.js中定义格式化时间的方法</p></li><li><p>在index.js中定义转义HTML的方法</p></li><li><p>在index.js中定义还原HTML的方法</p></li><li><p>将不同的功能进行模块化拆分</p><ol><li>将格式化时间的功能，拆分到src -&gt; dataFormat.js中</li><li>将处理HTML字符串的功能，拆分到src -&gt; htmlEscape.js中</li><li>在index.js中，导入两个模块，得到需要向外共享的方法</li><li>在index.js中，使用module.exports把对应的方法共享出去</li></ol></li><li><p>编写包的说明文档</p><p> 包根目录中的README.md文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以markdown的格式写出来，方便用户参考.</p><p> README文件中具体写什么内容，说明强制性的要求；只要能够清晰地把包地作用、用法、注意事项等描述清楚即可。</p><p> 我们所创建地这个包地README.md文档中，会包含以下6项内容；</p><p> 安装方式、导入方式、格式化时间、转义HTML中地特殊字符、还原HTML中的特殊字符、开源协议</p></li></ol><p>8、注册npm账号</p><ol><li><p>注册npm账号</p><ol><li>访问<a href="https://www.npmjs.com/">npm</a> 网站，点击sign up按钮，进入注册用户界面</li><li>填写账号相关的信息：Full Name、Public Email、Username、Password</li><li>点击Create an Account按钮，注册账号</li><li>登录邮箱，点击验证链接，进行账号的验证</li></ol></li><li><p>登录npm账号</p><p> npm注册注册完后，可以在终端中执行npm login命令，依次输入用户名、密码、邮箱后，即可登录成功</p><pre><code class="hljs"> 注意：在运行npm login命令之前，必须先把下包的服务器地址切换为npm的官方服务器，否则会导致发布包失败</code></pre></li><li><p>把包发布到npm上</p><p> 将终端切换到包的根目录之后，运行npm publish命令，即可将包发布到npm上(注意：包名不能雷同)。</p></li><li><p>删除已发布的包</p><p> 运行npm unpublish包名 –force命令，即可从npm删除已发布的包。</p><blockquote><p>注意：<br>     1. npm unpublish命令只能删除72小时以内发布的包<br>     2. npm unpublish删除的包，在24小时内不允许重复发布<br>     3. 发布包的时候要慎重，尽量不要往npm上发布没有意义的包！</p></blockquote></li></ol><h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><p>1、优先从缓存中加载</p><pre><code class="hljs">模块在第一次加载后会被缓存。在这也意味着多次调用require()不会导致模块的代码被执行多次注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</code></pre><p>2、内置模块的加载机制</p><pre><code class="hljs">内置模块是由Node.js官方提供的模块，内置模块的加载优先级最高。例如，require(&#39;fs&#39;)始终返回内置的fs模块，即使在node_modules目录下有名字相同的包也叫做fs</code></pre><p>3、自定义模块的加载机制</p><pre><code class="hljs">使用require()加载自定义模块时，必须指定以./或../开头的路径标识符。在加载自定义模块时，如果没有指定./或../这样的路径标识符，则node会把它当作内置模块或第三方模块进行加载同时，在使用require()导入自定义模块时，如果省略了文件的扩展名，则Node.js会按顺序分别尝试加载以下的文件：1. 按照确切的文件名进行加载2. 补全.js扩展名进行加载3. 补全.json扩展名进行加载4. 补全.node扩展名进行加载5. 加载失败，终端报错</code></pre><p>4、 第三方模块的加载机制</p><pre><code class="hljs">如果传递给require()的模块标识符不是一个内置模块，也没有以&#39;./&#39;或&#39;../&#39;开头，则Node.js会从当前模块的父目录开始，尝试从/node_modules文件夹中加载第三方模块如果没有找到对应的第三方模块，则移动到上一层父目录中，进行加载，直到文件系统的根目录。例如，假设在&#39;C:/Users/dsds/dsds/dsd/foo.js&#39;文件里调用了require(&#39;tools&#39;)，则Node.js会按以下顺序查找：</code></pre><p>5、目录作为模块</p><pre><code class="hljs">当目录作为模块标识符，传递给require()进行加载的模块，有以下三种方式：1. 在被加载的目录下查找一个叫做package.json的文件，并寻找main属性，作为require()加载的入口2. 如果目录里没有package.json文件，或者main入口不存在或无法解析，则Node.js会试图加载目录下的index.js文件3. 如果以上两步都失败了，则Node.js会在终端打印错误消息，报告模块的缺失：Error:Cannot find module &#39;xxx&#39;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node_express</title>
    <link href="/2023/03/10/node-express/"/>
    <url>/2023/03/10/node-express/</url>
    
    <content type="html"><![CDATA[<p>一、初始Express</p><p>1、Express简介</p><ol><li><p>什么是Express</p><p> 官方给出的概念：Express是基于Node.js平台，快速、开发、极简的Web开发框架。</p><p> 通俗的理解：Express的作用和Node.js内置的http模块类似，是专门用来创建Web服务器的。</p><p> Express的本质：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法</p><pre><code class="hljs"> Express的中文官网：http://www.expressjs.com.cn/</code></pre></li><li><p>进一步理解Express</p><p> 思考：不使用Express能否创建Web服务器？<br> 答案：能，使用Node.js提供的原生http模块即可</p><p> 思考：有了http内置模块，为什么还有用Express？<br> 答案：http内置模块用起来很复杂，开发效率低；Express是基于内置的http模块进一步封装出来的，能够极大的提高开发效率。</p><p> 思考：http内置模块与Express是什么关系？<br> 答案：类似于浏览器中Web API和jQuery的关系，后者是基于前者进一步封装出来的</p></li><li><p>Express能做什么</p><p> 对于前端程序员来说，最常见的两种服务器，分别是：</p><pre><code class="hljs"> Web网站服务器：专门对外提供Web网页资源的服务器 API接口服务器：专门对外提供API接口的服务器 使用Express，我们可以方便、快速的创建Web网站的服务器或API的服务器。</code></pre></li></ol><p>2、Express的基本使用</p><ol><li><p>安装</p><p> 在项目所处的目录中，运行如下的终端命令，即可将express安装到项目中使用；</p><pre><code class="hljs"> npm install express@4.17.1</code></pre></li><li><p>创建基本的Web服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入express</span><br><span class="hljs-keyword">const</span> express=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//2. 创建web服务器</span><br><span class="hljs-keyword">const</span> app=<span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//3. 调用app.listen(端口号，启动成功后的回调函数)，启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server runing at http://127.0.0.1&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>监听GET请求</p><p> 通过app.get()方法，可以监听客户端的GET请求，具体的语法格式如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>参数<span class="hljs-number">1</span>：客户端请求的URL地址<br><span class="hljs-regexp">//</span>参数<span class="hljs-number">2</span>：请求对应的处理函数<br><span class="hljs-regexp">//</span>          req：请求对象(包含了与请求相关的属性与方法)<br><span class="hljs-regexp">//</span>          res：响应对象(包含了与相应相关的属性与方法)<br>app.get(<span class="hljs-string">&#x27;请求URL&#x27;</span>,<span class="hljs-keyword">function</span>(req,res)&#123;<span class="hljs-regexp">/*处理函数*/</span>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li><p>监听POST请求</p><p> 通过app.post()方法，可以监听客户端的POST请求，具体的语法格式如下：</p></li><li><p>把内容响应给客户端</p><p> 通过res.send()方法，可以把处理好的内容，发送给客户端：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>    <span class="hljs-regexp">//</span>向客户端发送<span class="hljs-built_in">JSON</span>对象<br>    res.send(&#123;name:<span class="hljs-string">&#x27;zs&#x27;</span>,age:<span class="hljs-number">20</span>,gender:<span class="hljs-string">&#x27;男&#x27;</span>&#125;)<br>&#125;)<br>app.post(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>    <span class="hljs-regexp">//</span>向客户端发送文本内容<br>    res.send(<span class="hljs-string">&#x27;请求成功&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li><p>获取URL中携带的查询参数</p><p> 通过req.query对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">app.get(<span class="hljs-string">&#x27;/&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-regexp">//</span>req.query默认是一个空对象<br>    <span class="hljs-regexp">//</span>客户端使用?name=zs&amp;age=<span class="hljs-number">20</span>这种查询字符串形式，发送到服务器的参数<br>    <span class="hljs-regexp">//</span>可以通过req.query对象访问到，例如：<br>    <span class="hljs-regexp">//</span>req.query.name<br>    console.log(req.query)<br>  &#125;)<br></code></pre></td></tr></table></figure><ol start="7"><li><p>获取URL中的动态参数</p><p> 通过req.params对象，可以访问到URL中，通过：匹配到的动态参数：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//req.params默认是一个空对象</span><br>    <span class="hljs-comment">//里面存放着通过：动态匹配到的参数值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>3、托管静态资源</p><ol><li><p>express.static()</p><p> express提供了一个非常好用的函数，叫做express.staic()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将public目录下的图片、CSS文件、javascript文件对外开放访问了</p></li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">app.<span class="hljs-keyword">use</span>(express.static(<span class="hljs-symbol">&#x27;public</span>));<br></code></pre></td></tr></table></figure><pre><code class="hljs">    注意：Express在指定静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在URL中</code></pre><ol start="2"><li><p>托管多个静态资源目录</p><p> 如果要托管多个静态资源目录，请多次调用express.static()函数：</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">app.<span class="hljs-keyword">use</span>(express.<span class="hljs-built_in">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));<br>app.<span class="hljs-keyword">use</span>(express.<span class="hljs-built_in">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>));<br></code></pre></td></tr></table></figure><pre><code class="hljs">访问静态资源文件时，express.static()函数会根据目录的添加顺序查找所需的文件</code></pre><ol start="3"><li><p>挂载路径前缀</p><p> 如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#x27;/public&#x27;</span>,express.<span class="hljs-built_in">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">现在，你就可以通过带有/public前缀地址来访问public目录中的文件了；        </code></pre><p>4、nodemon</p><ol><li><p>为什么要使用nodemon</p><p> 在编写调试Node.js项目的时候，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常频锁。</p><p> 现在，我们可以使用<a href="https://www.npmjs.com/package/nodeman">nodeman</a>这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon会自动帮我们重启项目，极大方便了开发和调试</p></li><li><p>安装nodemon</p><p> 再终端中，运行如下命令，即可将nodemon安装为全局可用的工具；</p></li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> nodemon -g<br></code></pre></td></tr></table></figure><ol start="3"><li><p>使用nodemon</p><p> 当基于Node.js编写了一个网站应用的时候，传统的方式，是运行node app.js命令，来启动项目。这样做的坏处是：代码被修改后，需要手动重启项目。</p><p> 现在，我们可以将node命令nodemon命令后，使用nodemon app.js来启动项目，这样做的好处是：代码被修改之后，会被nodemon app.js来启动项目，这样做的好处是：代码被修改之后，会被nodemon监听到，从而实现自动重启项目的效果</p></li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">app</span>.js<br>//将上面的终端命令，替换为下面的终端命令，即可实现自动重启项目的效果<br>nodemon app.js<br></code></pre></td></tr></table></figure><p>2、路由的概念</p><ol><li><p>什么是路由</p><p> 广义上来讲，路由就是映射关系。</p></li><li><p>现实生活中的路由</p><p> 路由时按键与服务之间的映射关系</p></li><li><p>Express中的路由</p><p> 在Express中，路由指的是客户端的请求与服务器处理函数之间的映射关系<br> EXpress中的路由分3部分组成，分别是请求的类型、请求的URL地址、处理函数，格式如下：</p></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">app.<span class="hljs-keyword">METHOD</span>(<span class="hljs-type">PATH</span>,<span class="hljs-keyword">HANDLER</span>)<br></code></pre></td></tr></table></figure><ol start="4"><li><p>Express中的路由的例子</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">//匹配GET请求，且请求<span class="hljs-built_in">URL</span>为/<br>app.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">req</span>,<span class="hljs-title">res</span>)&#123;</span><br>    res.<span class="hljs-built_in">send</span>(<span class="hljs-string">&#x27;Mello World!&#x27;</span>)<br>&#125;)<br><span class="hljs-comment"></span><br><span class="hljs-comment">//匹配POST请求，且请求URL为/</span><br>app.<span class="hljs-built_in">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">req</span>,<span class="hljs-title">res</span>)&#123;</span><br>    res.<span class="hljs-built_in">send</span>(<span class="hljs-string">&#x27;Got a POST requst!&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>路由的匹配过程</p><p> 每当一个请求到达服务器之后，需要先经过路由的匹配，只是匹配成功之后，才会调用对应的处理函数</p><p> 在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express会将这次请求，转交给对应的function函数进行处理</p><p> 路由匹配的注意点：</p><pre><code class="hljs"> 1. 按照定义的先后顺序进行匹配 2. 请求类型和请求的URL同时匹配成功，才会调用对应的处理函数</code></pre></li></ol><p>2、路由的使用</p><ol><li><p>最简单的用法</p><p> 在Express中使用路由最简单的方式，就是把路由挂载到app上，示例代码如下：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建web服务器，命名为app</span><br><span class="hljs-keyword">const</span> app=<span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//挂载路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,(req,res)=?&#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>)&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>,(req,res)=?&#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>)&#125;)<br><span class="hljs-comment">//启动Web服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server runing at http://127.0.0.1&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>模块化路由</p><p> 为了方便对路由进行模块化的管理，Express不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块。<br> 将路由抽离为单独模块的步骤如下：</p><pre><code class="hljs"> 1. 创建路由模块对应的js文件 2. 调用express.Router()函数创建路由对象 3. 向路由对象上挂载具体的路由 4. 使用module.exports向外共享路由对象 5. 使用app.use()函数注册路由模块</code></pre></li><li><p>创建路由模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);   <span class="hljs-comment">//1. 创建路由模块对应的js文件</span><br><span class="hljs-keyword">var</span> router=express.<span class="hljs-title class_">Router</span>();  <span class="hljs-comment">//2. 调用express.Router()函数创建路由对象</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list&#x27;</span>);<br>    &#125;)  <span class="hljs-comment">//3. 向路由对象上挂载具体的路由</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user&#x27;</span>);<br>&#125;)  <span class="hljs-comment">//4. 使用module.exports向外共享路由对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">express</span>=router;  <span class="hljs-comment">//5. 使用app.use()函数注册路由模块</span><br></code></pre></td></tr></table></figure></li><li><p>注册路由模块</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 导入路由模块<br>const userRouter=require(<span class="hljs-string">&#x27;./user.js&#x27;</span>)<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 使用app.use()注册路由模块<br>app.use(userRouter)<br><span class="hljs-regexp">//</span> 注意app.use()函数的作用，就是来注册全局中间件<br></code></pre></td></tr></table></figure></li><li><p>为路由模块添加前缀</p><p> 类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//1. 导入路由模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">userRouter</span>=<span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./router/user.js&#x27;</span>)<br><span class="hljs-comment">//2. 使用app.use()注册路由模块，并添加统一的访问前缀/api</span><br>app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>,userRouter)<br></code></pre></td></tr></table></figure><p>3、中间件的概念</p><ol><li><p>什么时中间件</p><p> 中间件(Middleware)，特指业务流程的中间处理环节。</p></li><li><p>现实生活中的例子</p><p> 在处理污水中，一般都要经过三个处理环节，从而保证处理过后的污水，达到排放标准</p><p> 处理污水的这三个处理环节，就可以叫做中间件</p></li><li><p>Express中间件的调理流程</p><p> 当一个请求达到Express的服务器之后，可以连续选择调用多个中间件，从而对这次请求进行预处理</p></li><li><p>Express中间件的格式</p><p> Express的中间件，本质上将是一个function处理函数，Express中间件的格式如下：</p><pre><code class="hljs"> 注意：中间件函数的形参列表中，必须包含next参数，而路由处理函数只包含req和res</code></pre></li><li><p>next函数的作用</p><p> next函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由</p></li></ol><p>2、Express中间件的初体验</p><ol><li><p>定义中间件函数</p><p> 通过如下的方式，定义一个最简单的中间件函数：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>常量mw所指向的，就是一个中间件函数<br>const mw=<span class="hljs-keyword">function</span>(req,res,<span class="hljs-keyword">next</span>)&#123;<br>    <span class="hljs-regexp">//</span>注意：在当前中间件的业务处理完毕后，必须调用<span class="hljs-keyword">next</span>()函数<br>    <span class="hljs-regexp">//</span>表示把流转关系转交给下一个中间件或路由<br>    <span class="hljs-keyword">next</span>()<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>全局生效的中间件</p><p> 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。<br> 通过调用app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>常量mw所指向的，就是一个中间件函数<br>const mw=<span class="hljs-keyword">function</span>(req,res,<span class="hljs-keyword">next</span>)&#123;<br>    console.log(<span class="hljs-string">&#x27;这是最简单的中间件函数&#x27;</span>)<br>    <span class="hljs-keyword">next</span>();<br>&#125;<br><br><span class="hljs-regexp">//</span>全局生效的中间件<br>app.use(mw);<br></code></pre></td></tr></table></figure><ol start="3"><li><p>定义全局中间件的简化形式</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//全局生效的中间件</span><br>app.use(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;这是一个最简单的中间函数&#x27;</span>);<br>    next();<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>中间件的作用</p><p> 多个中间件之间，共享同一份req和res。基于这样的特性，我们可以在上游的中间件中，统一为req或res对象添加自定义的属性或方法，供下游的中间件或路由进行使用。</p></li><li><p>定义多个全局中间件</p><p> 可以使用app.use()连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">app.use(<span class="hljs-keyword">function</span>(req,res,<span class="hljs-keyword">next</span>)&#123;<span class="hljs-regexp">//</span>第一个全局中间件<br>    console.log(<span class="hljs-string">&#x27;调用第一个全局中间件&#x27;</span>)<br>    <span class="hljs-keyword">next</span>();<br>&#125;)<br>  app.use(<span class="hljs-keyword">function</span>(req,res,<span class="hljs-keyword">next</span>)&#123;<span class="hljs-regexp">//</span>第一个全局中间件<br>    console.log(<span class="hljs-string">&#x27;调用第二个全局中间件&#x27;</span>)<br>    <span class="hljs-keyword">next</span>();<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/user&#x27;</span>,(req,res)=&gt;&#123;<span class="hljs-regexp">//</span>请求这个路由，会依次触发上述两个全局中间件<br>res.send(<span class="hljs-string">&#x27;Home page&#x27;</span>);<br><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li><p>局部生效的中间件</p><p> 不使用app.use()定义的中间件，叫做局部生效的中间件，示例代码如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>定义代码中间件函数 mw1<br>const mw1=<span class="hljs-keyword">function</span>(req,res,<span class="hljs-keyword">next</span>)&#123;<br>    console.log(<span class="hljs-string">&#x27;这是中间件函数&#x27;</span>)<br>    <span class="hljs-keyword">next</span>();<br>&#125;<br><br><span class="hljs-regexp">//m</span>w1这个中间件只在<span class="hljs-string">&#x27;当前路由中生效&#x27;</span>，这种用法属于<span class="hljs-string">&#x27;局部生效的中间件&#x27;</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,mv1,<span class="hljs-keyword">function</span>(req,res)&#123;<br>    res.send(<span class="hljs-string">&#x27;Home page.&#x27;</span>)<br>&#125;)<br><span class="hljs-regexp">//m</span>w1这个中间件不会影响下面这个路由<br>app.get(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-keyword">function</span>(req,res)&#123;<br>    res.send(<span class="hljs-string">&#x27;User page&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="7"><li><p>定义多个局部中间件</p><p> 可以在路由中，通过如下两种等价的方式，使用多个局部中间件：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>以下两种写法是<span class="hljs-string">&#x27;完全等价&#x27;</span>的，可根据自己的喜好，选择任意一种方式进行使用<br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,mw1,mw2,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;Home page&#x27;</span>)<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,[mw1,mw2],<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;Home page&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="8"><li><p>了解中间件的5个注意事项</p><ol><li>一定要在路由之前注册中间件</li><li>客户端送过来的请求，可以连续调用多个中间件进行处理</li><li>执行完中间件的业务代码之后，不要忘记调用next()函数</li><li>为了防止代码逻辑混乱，调用next()函数后不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间，共享req和res对象</li></ol></li></ol><p>3、中间件的分类</p><pre><code class="hljs">为了方便大家理解和记忆，中间件的使用，Express官方把常见的中间件用法，分成了5大类，分别是：    1. 应用级别的中间件    2. 路由级别的中间件    3. 错误级别的中间件    4. Express内置的中间件    5. 第三方的中间件</code></pre><ol><li><p>应用级别的中间件</p><p> 通过app.use()或app.get()或app.post(),绑定到app实例上的中间件，叫做应用级别的中间件，代码示例如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>应用级别的中间件(全局中间件)<br>app.use(req,res,<span class="hljs-keyword">next</span>)=&gt;&#123;<br>    <span class="hljs-keyword">next</span>();<br>&#125;<br><br><span class="hljs-regexp">//</span>应用级别的中间件(局部中间件)<br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,mw1,(req,res)=&gt;&#123;<br>    res.send(<span class="hljs-string">&#x27;Home page.&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>路由级别的中间件</p><p> 绑定到express.Router()实例上的中间件，叫做路由级别的中间件，它的用法和和应用级别中间件没有任何区别，只不过，应用级别中间件是绑定到app实例上，路由级别中间件绑定到router实例上，代码示例如下：</p></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> app=express();<br><span class="hljs-keyword">var</span> router=express.Router();<br><br><span class="hljs-comment">//路由级别的中间件</span><br>router.use(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Time&#x27;</span>,<span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>())<br>    next()<br>&#125;)<br><br>app.use(<span class="hljs-string">&#x27;/&#x27;</span>,router);<br></code></pre></td></tr></table></figure><ol start="3"><li><p>错误级别的中间件</p><p> 错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。</p><p> 格式：错误级别中间件的function处理函数中，必须有4个参数，形参顺序从前到后，分别是(err,req,res,next)</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">app.get(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(req,res)&#123;      <span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 路由<br>    throw new Error(<span class="hljs-string">&#x27;服务器内部发生了错误！&#x27;</span>)<span class="hljs-regexp">//</span><span class="hljs-number">1.1</span>抛出一个自定义的错误<br>    res.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>);<br>&#125;)<br><br>app.use(<span class="hljs-keyword">function</span>(err,req,res,<span class="hljs-keyword">next</span>)&#123;     <span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 错误级别的中间件<br>console.log(<span class="hljs-string">&#x27;发生了错误&#x27;</span>+err.message)<span class="hljs-regexp">//</span><span class="hljs-number">2.1</span>在服务器打印错误消息<br>res.send(<span class="hljs-string">&#x27;Error&#x27;</span>+err.message)   <span class="hljs-regexp">//</span><span class="hljs-number">2.2</span>向客户端响应错误相关的内容<br><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>注意：错误级别中间件，必须注册在所有路由之后</p></blockquote><ol start="4"><li><p>Express内置的中间件</p><p> 自Express4.16.0把版本开始，Express内置了3个常用的中间件，极大的提高了Express项目的开发效率和体验：</p><pre><code class="hljs"> 1. express.static快速托管静态资源的内置中间件，例如：HTML文件、图片、CSS样式等(无兼容性)  2.express.json解析JSON格式的请求数据(有兼容性，仅在4.16.0+版本中可用)  3. express.urlencoded解析URL-encoded格式的请求体数据(有兼容性，仅在4.16.0+版本中可用)</code></pre></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//配置解析application/json格式数据的内置中间件</span><br>app.<span class="hljs-keyword">use</span>(express.<span class="hljs-title function_ invoke__">json</span>())<br><span class="hljs-comment">//配置解析application/x-www-form-urlencoded格式数据的内置中间件</span><br>app.<span class="hljs-keyword">use</span>(express.<span class="hljs-title function_ invoke__">urlencoded</span>(&#123;<span class="hljs-attr">extended</span>:<span class="hljs-literal">false</span>&#125;))<br></code></pre></td></tr></table></figure><ol start="5"><li><p>第三方的中间件</p><p> 非Express官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件，在项目中，大家可用按需下载并配置第三方中间件，从而提高项目的开发效率</p><p> 例如：在<a href="mailto:&#x65;&#x78;&#112;&#x72;&#x65;&#115;&#115;&#x40;&#x34;&#x2e;&#49;&#54;&#x2e;&#x30;">&#x65;&#x78;&#112;&#x72;&#x65;&#115;&#115;&#x40;&#x34;&#x2e;&#49;&#54;&#x2e;&#x30;</a>之前的版本中，经常body-parser这个第三方中间件，来解析请求体数据。使用步骤如下：</p><pre><code class="hljs"> 1. 运行npm install  2. body-parser安装中间件 3. 调用app.use()注册并使用中间件 注意：Express内置的express.urlencoded中间件，就是基于body-parse这个第三方中间件进一步封装出来的</code></pre></li></ol><p>4、自定义中间件</p><ol><li><p>需求描述与实现步骤</p><p> 自己手动模拟一个类似于express.urlencoded这样的中间件，来解析post提交到服务器的表单数据</p><p> 实现步骤：</p><pre><code class="hljs"> 1. 定义中间件 2. 监听req的data事件 3. 监听req的end事件 4. 使用querystring模块解析请求体数据 5. 将解析出来的数据对象挂载为req.body 6. 将自定义中间件封装为模块</code></pre></li><li><p>定义中间件</p><p> 使用app.use()来定义全局生效的中间件，代码如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">app.sue(<span class="hljs-keyword">function</span>(req,res,<span class="hljs-keyword">next</span>)&#123;<br>    <span class="hljs-regexp">//</span>中间件的业务逻辑<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>监听req的data事件</p><p> 在中间件中，需要监听req对象的data对象，来获取客户端发送到服务器的数据。</p><p> 如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以data事件可能会触发多次，每一次触发data事件时，获取到数据只是完整数据的一部分，需要手动对接受到的数据进行拼接</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>定义变量，用来存储客户端发送过来的请求体数据<br>let str=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-regexp">//</span>监听req对象的data事件(客户端发送过来的新的请求体数据)<br>req.on(<span class="hljs-string">&#x27;data&#x27;</span>,(chunk)=&gt;&#123;<br>    <span class="hljs-regexp">//</span>拼接请求体数据，隐式转换为字符串<br>    str+=chunk;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li><p>监听req的end事件</p><p> 当请求体数据接收完毕之后，会自动触发req的end事件</p><p> 因此，我们可用在req的end事件中，拿到并处理完整的请求体数据。示例代码如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>监听req对象end事件(请求体发送完毕后自动触发)<br>req.on(<span class="hljs-string">&#x27;end&#x27;</span>,()=&gt;&#123;<br>    <span class="hljs-regexp">//</span>打印完整的请求体数据<br>    console.log(str)<br>    <span class="hljs-regexp">//</span>TODO：把字符串格式的请求体数据，解析成对象格式<br><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>使用querystring模块解析请求体数据</p><p> Node.js内置了一个querystring模块，专门用来处理查询字符串。通过这个模块提供的parse()函数，可用轻松把查询字符串，解析成对象的格式，示例代码如下：</p></li></ol><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//导入处理querystring的Node.js内置模块</span><br><span class="hljs-keyword">const</span> qs=require(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br><span class="hljs-comment">//调用qs.parse()方法，把查询字符串解析为对象</span><br><span class="hljs-keyword">const</span> body=qs.parse(<span class="hljs-built_in">str</span>);<br></code></pre></td></tr></table></figure><ol start="6"><li><p>将解析出来的数据对象挂载为req.body</p><p> 上游的中间件和下游的中间件及路由之间，共享同一份req和res，因此，我们可用将解析出来的数据，挂载为req的自定义属性，命名为req.body，供下游使用。示例代码如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">req.on(<span class="hljs-string">&#x27;end&#x27;</span>,()=&gt;&#123;<br>    const body=qs.parse(str)<span class="hljs-regexp">//</span>调用qs.parse()方法，把查询字符串解析为对象<br>    req.body=body<span class="hljs-regexp">//</span>将解析出来的请求体对象，挂载为req.body属性<br>    <span class="hljs-keyword">next</span>()<span class="hljs-regexp">//</span>最后，一定也要调用<span class="hljs-keyword">next</span>()函数，执行后续的业务逻辑<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="7"><li><p>将自定义中间件封装为模块</p><p> 为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//custom-body-parser.js模块中的代码</span><br><span class="hljs-keyword">const</span> qs=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bodyParser</span>(<span class="hljs-params">req,res,next</span>)&#123;  &#125;<br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=bodyParser<span class="hljs-comment">//向外导出解析请求体数据的中间件函数</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">//1. 导入自定义的中间件模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">myBodyParser</span>=<span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;custom-body-parser&#x27;</span>)<br><span class="hljs-comment">//2. 注册自定义的中间件模块</span><br>app.<span class="hljs-keyword">use</span>(myBodyParser)<br></code></pre></td></tr></table></figure><p>四、使用Express写接口</p><p>1、 创建基本的服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>2、创建API路由模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//apiRouter.js[路由模块]</span><br><span class="hljs-keyword">const</span> express=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> apiRouter=express.<span class="hljs-title class_">Router</span>()<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=apoRouter<br><br><span class="hljs-comment">//app.js[导入并注册路由模块]</span><br><span class="hljs-keyword">const</span> apiRouter=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./apiRouter.js&#x27;</span>);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;./api&#x27;</span>,apiRouter);<br></code></pre></td></tr></table></figure><p>3、编写GET接口</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">apiRouter.get(<span class="hljs-string">&#x27;/get&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 获取客户端通过查询字符串，发送到服务器的数据<br>    const query=req.query<br>    <span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 调用res.send()方法，把数据响应给客户端<br>    res.send(&#123;<br>        status:<span class="hljs-number">0</span>,<span class="hljs-regexp">//</span>状态，<span class="hljs-number">0</span>表示成功，<span class="hljs-number">1</span>表示失败<br>        msg:<span class="hljs-string">&#x27;GET请求成功&#x27;</span>,<span class="hljs-regexp">//</span>状态描述<br>        data:query<span class="hljs-regexp">//</span>需要响应给客户端的具体数据<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>4、编写POST接口</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">apiRouter.post(<span class="hljs-string">&#x27;/post&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 获取客户端通过请求体，发送到服务器的URL-encoded数据<br>    const body=req.body<br>    <span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 调用res.send()方法，把数据响应给客户端<br>    res.send(&#123;<br>         status: <span class="hljs-number">0</span>,<span class="hljs-regexp">//</span>状态，<span class="hljs-number">0</span>表示成功，<span class="hljs-number">1</span>表示失败<br>        msg: <span class="hljs-string">&#x27;GET请求成功&#x27;</span>,<span class="hljs-regexp">//</span>状态描述<br>        data: body<span class="hljs-regexp">//</span>需要响应给客户端的具体数据<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果要获取URL-encoded格式的请求体数据，必须配置中间件app.use(express.urlencoded({extended:false}))</p></blockquote><p>5、CORS跨域资源共享</p><ol><li><p>接口的跨域问题</p><p> 刚才编写的GET和POST接口，存在一个很严重的问题：不支持跨域请求</p><p> 解决接口跨域问题的方案主要有两种：</p><pre><code class="hljs"> 1. CORS(主流的解决方案，推荐使用) 2. JSONP(有缺陷的解决方案：只支持GET请求)</code></pre></li><li><p>使用cors中间件解决跨域问题</p><p> cors是Express的一个第三方中间件，通过安装和配置cors中间件，可以很方便的解决跨域问题</p><p> 使用步骤分为如下3步：</p><pre><code class="hljs"> 1. 运行npm install cors 安装中间件 2. 使用const cors =require(&#39;cors&#39;)导入中间件 3. 在路由之前调用app.use(cors())配置中间件</code></pre></li><li><p>什么是CORS</p><p> CORS(Cross-Origin Resource Sharing,跨资源共享)由一系列HTTP响应头组成，这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源</p><p> 浏览器的同源安全策略默认会阻止网页”跨域”获取资源，但如果接口服务器配置了CORS相关的HTTP响应头，就可以接触浏览器端的跨域访问限制</p></li><li><p>CORS的注意事项</p><ol><li><p>CORS主要在服务器进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了CORS的接口</p></li><li><p>CORS在浏览器中有兼容性。只有支持XMLHttpRequest Level2的浏览器，才能正常访问开启了CORS的服务端接口(例如：IE10+、Chrome4+、FireFox3.5+)</p></li></ol></li><li><p>CORS响应头部 - Access-Control-Allow-Origin</p><p> 响应头中可以携带一个Access-Control-Allow-Origin字段，其语法如下：</p><pre><code class="hljs"> Access-Control-Allow-Origin:&lt;origin&gt;|* 其中，origin参数的值指定允许访问该资源的外域URL 例如，下面的字段值将只允许来自http://itcast.cn的请求： res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://itcast.cn&#39;)</code></pre><p> 如果指定了Access-Control-Allow-Origin字段的值为通配符*，表示允许来自任何域的请求，示例代码如下：</p><pre><code class="hljs"> res.Header(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);</code></pre></li><li><p>CORS响应头头部-Access-Control-Allow-Headers</p><p> 默认情况下，CORS仅支持客户端向服务器发送如下的9个请求头：</p><pre><code class="hljs"> Accept Accept-Language Content-Language DPR Downlink Save-Data Viewport-Width Width Content-Type(值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三者之一)</code></pre><p> 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers对额外的请求头进行声明，否则这次请求会失败！</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>允许客户端额外向服务器发送 Content-Type请求头和X-Custom-Header请求头<br><span class="hljs-regexp">//</span>注意：多个请求头之间使用英文的都好进行分割<br>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="hljs-string">&#x27;Content-Type,X-Custom-Header&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="7"><li><p>CORS响应头部-Access-Control-Allow-Methods</p><p> 默认情况下，CORS仅支持客户端发起GET、POST、HEAD请求。</p><p> 如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Allow-Methods来指明实际请求所允许适用范围的HTTP方法</p><p> 示例代码如下：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>只允许POST、GET、DELETE、HEAD请求方法<br>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="hljs-string">&#x27;POST,GET,DELETE,HEAD&#x27;</span>)<br><span class="hljs-regexp">//</span>允许所有的HTTP请求方法<br>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="8"><li><p>CORS请求的分类</p><p> 客户端在请求CRS接口时，根据请求方式和请求头的不同，可以将CORS的请求分为两大类，分别是：</p><pre><code class="hljs"> 1. 简单请求 2. 预检请求</code></pre></li><li><p>简单请求</p><p> 同时满足以下两大条件的请求，就属于简单请求：</p><ol><li><p>请求方式：</p><p> GET<br> POST<br> HEAD(三者之一)</p></li><li><p>HTTP头部信息不超过以下几种字段：</p><p> 无自定义头部字段<br> Accept<br> Accept-Language<br> Content-Language<br> DPR<br> Downlink<br> Save-Data<br> Viewport-Width<br> Width<br> Content-Type(只有三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain)</p></li></ol></li><li><p>预检请求</p><p>只要符合以下任何一个条件的请求，都需要进行预检请求</p><ol><li>请求方式GET、POST、HEAD之外的请求Method类型</li><li>请求头中包含自定义头部字段</li><li>向服务器发送了application&#x2F;json格式的数据</li></ol><p>在浏览器与服务器正式通信之前，浏览器会先发送OPTION请求进行预检，已获知服务器是否允许该实际请求，所以这一次的OPTION请求称为”预检请求”。服务器成功响应预检请求后，才会发送真正请求，并且携带真实数据</p></li><li><p>简单请求和预检请求的区别</p><p>简单请求的特点：客户端与服务器只会发生一次请求</p><p>预检请求的特点：客户端与服务器之间会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求</p></li></ol><p>6、JSONP接口</p><ol><li><p>回顾JSONP的概念与特点</p><p> 概念：浏览器通过&lt;script&gt;标签src属性，请求服务器上的数据，同时服务器返回一个函数的调用。这种请求数据的方式叫做JSONP。</p><pre><code class="hljs"> 特点： 1. JSONP不属于真正的Ajax请求，因为它没有使用XMLHttpRequest这个对象 2. JSON仅支持GET请求，不支持POST、PUT、DELETE等请求</code></pre></li><li><p>创建JSON接口的注意事项</p><p> 如果项目中已经配置了CORS跨域资源共享，为了防止冲突，必须在配置CORS中间件之前声明JSONP的接口。否则JSONP接口会被处理成开启了CORS的接口。示例代码如下：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>优先创建JSONP接口【这个接口不会被处理成CORS接口】<br>app.get(<span class="hljs-string">&#x27;/api/jsonp&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;&#125;)<br><span class="hljs-regexp">//</span>再配置CORS中间件【后续的所有接口，都会被处理成CORS接口】<br>这是一个开启了CORS的接口<br>app.get(<span class="hljs-string">&#x27;/api/get&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>实现JSONP接口的步骤</p><ol><li>获取客户端发送过来的回调函数的名字</li><li>得到要通过JSONP形式发送给客户端的数据</li><li>根据前两步得到的数据，拼接出一个函数调用的字符串</li><li>把上一步拼接得到的字符串，响应给客户端的&lt;script&gt;标签进行解析执行</li></ol></li><li><p>实现JSONP接口的具体代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">app.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/api/jsonp&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//1. 获取客户端发送过来的回调函数的名字</span><br>    <span class="hljs-keyword">const</span> funcName=req.query.callback<br>    <span class="hljs-comment">//2. 得到要通过JSONP形式发送给客户端的数据</span><br>    <span class="hljs-keyword">const</span> data=&#123;name,<span class="hljs-string">&#x27;zs&#x27;</span>,age20&#125;<br>    <span class="hljs-comment">//3. 根据前两步得到的数据，拼接出一个函数调用的字符串</span><br>    <span class="hljs-keyword">const</span> scritStr=<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;funcName&#125;</span>(<span class="hljs-subst">$&#123;JSON.stringify(data)&#125;</span>)&#x27;</span>;<br>    <span class="hljs-comment">//4. 把上一步拼接得到的字符串，响应给客户端的&amp;lt;script&gt;标签进行解析执行</span><br>    res.send(scriptStr)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>在网页中使用jQuery发起就JSONP请求</p><p> 调用$.ajax()函数，提供JSONP的配置选项，从而发起JSONP请求，示例代码如下：</p></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(<span class="hljs-string">&#x27;#btnJSONP&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-symbol">$a</span>jax(&#123;<br>        <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;GET&#x27;</span>,<br>        <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://127.0.0.1/api/jsonp&#x27;</span>,<br>        <span class="hljs-attr">dataType</span>:<span class="hljs-string">&#x27;jsonp&#x27;</span>,<span class="hljs-comment">//表示要发起JSONP请求</span><br>        success:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>        &#125;<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node中mysql的应用</title>
    <link href="/2023/03/10/node-mysql/"/>
    <url>/2023/03/10/node-mysql/</url>
    
    <content type="html"><![CDATA[<p>一、数据库的基本概念</p><p>1、什么是数据库</p><pre><code class="hljs">数据库(database)是用来组织、存储和管理数据的仓库当今世界是一个充满这数据的互联网世界、充斥着大量的数据。数据的来源有很多，比如出行记录仪、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据、图像、音乐、声音都是数据为了方便管理互联网世界中的数据，就有了数据库管理系统的概念(简称：数据库)。用户可以对数据库中的数据进行新增、查询、更新、删除等操作</code></pre><p>2、常见的数据库及分类</p><pre><code class="hljs">市面上的数据库有很多种，最常见的数据库有如下几个：    MySQL数据库(目前最广泛、流行度最高的开源免费数据库；Community + Enterprise)    Oracle 数据库(收费)    SQL Server 数据库(收费)    Mongodb 数据库(Community + Enterprise)其中，MySQL、Oracle、SQL Server 属于传统型数据库(又叫做：关系型数据库或SQL数据库)，这三者的设计理念相同，用法比较类似而Mongodb属于新型数据库(又叫做：非关系型数据库或NOSQL数据库)，它在一定程度上弥补了传统型数据库的缺陷</code></pre><p>3、传统型数据库的数据组织结构</p><pre><code class="hljs">数据的组织结构：指的是数据以什么样的结构进行存储传统型数据库的数据组织结构，与excel中数据的组织结构比较类似因此，我们可以对比着excel来了解和学习传统数据库的数据组织结构</code></pre><ol><li><p>excel的数据组织结构</p><p> 在excel中，数据的组织结构分别是工作簿、工作表、数据行、列这4大部分组成。</p><ol><li>整个excel叫做工作簿</li><li>users和books是工作表</li><li>users工作表中有3行数据</li><li>每行数据由6列信息组成</li></ol></li><li><p>传统型数据库的数据组织结构</p><p> 在传统型数据库中，数据的组织分为数据库(database)、数据表(table)、数据行(row)、字段(field)这4大部分组成</p><ol><li>数据库类似于Excel的工作簿</li><li>数据表类似于Excel的工作表</li><li>数据行类似于Excel的每一行数据</li><li>字段类似于Excel的列</li><li>每个字段都有对应的数据类型</li></ol></li><li><p>实际开发中库、表、行、字段的关系</p><ol><li>在实际开发中，一般情况下，每个项目都对应独立的数据库</li><li>不同的数据，要存储到数据库的不同表中，例如：用户数据存储到users表中，图书数据存储到books表中</li><li>每个表中具体存储哪些信息，有字段来决定，例如：我们可以为users表表设计id、username、password这3个字段</li><li>表中的行，代表每一个具体的数据</li></ol></li></ol><p>二、安装并配置MySQL</p><p>1、了解需要安装哪些MySQL相关的软件</p><pre><code class="hljs">对于开发人员来说，只需要安装MySQL Server和MySQL Workbench这两个软件，就能满足开发的需要了MySQL Server:专门用来提供数据存储和服务的软件MySql Workbench:可视化的MySql管理工具，通过它，可以方便的操作存储在MySQL Server中的数据 </code></pre><p>2、MySQL在Mac环境下的安装</p><pre><code class="hljs">在Mac环境下安装MySQL的过程比windows环境下的步骤简单很多1. 先运行mysql-8.0.19-macos10.15-x86_64.dmg这个安装包，将MySQL Server安装到Mac系统2. 再运行mysql-workbench-community-8.0.19-macos-x86_64.dmg这个安装包，将可视化的Mysql Workbench工具安装到Mac系统</code></pre><p>3、MySQL在Windows环境下的安装</p><pre><code class="hljs">在Windows环境下安装MySQL，只需要运行mysql-installer-community-8.0.19.0.msi这个安装包，就能一次性将MySQL和MySQL Workbench安装到自己的电脑上</code></pre><p>三、MySQL的基本使用</p><p>1、使用Mysql Workbench管理数据库</p><ol><li><p>连接数据库</p></li><li><p>了解主页面的功能</p></li><li><p>创建数据库</p></li><li><p>创建数据表</p><p> DataType数据类型：</p><ol><li>int整数</li><li>varchar(len)字符串</li><li>tinyint(1)布尔值<br> 字段的特殊标识：</li><li>PK(Primary Key)主键、唯一标识</li><li>NN(Not Null)值不允许为空</li><li>UQ(Unique)值唯一</li><li>AI(Auto Increment)值自动增长</li></ol></li><li><p>向表中写入数据</p></li></ol><p>2、使用SQL管理数据库</p><ol><li><p>什么是SQL</p><p> SQL(英文全称：Structured Query Language)是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据</p><p> 三个关键点：</p><ol><li>SQL是一门数据库编程语言</li><li>使用SQL语言编写出来的代码，叫做SQL语句</li><li>SQL语言只能在关系型数据库中使用(例如MySQL、Oracle、SQL Server)。非关系型数据库(例如Mongodb)不支持SQL语言</li></ol></li><li><p>SQL能做什么</p><ol><li>从数据库中查询数据</li><li>向数据库中插入新的数据</li><li>更新数据库中的数据</li><li>从数据库删除数据</li></ol></li><li><p>SQL的学习目标</p><p> 重点掌握如何使用SQL从数据表中：</p><p> 查询数据(select)、插入数据(insert into)、更新数据(update)、删除数据(delete)</p><p> 额外需要掌握的4中SQL语法</p><p> where条件、and和or运算符、order by排序、count(*)函数</p></li></ol><p>3、SQL的SELECT语句</p><ol><li><p>语法</p><p> SELECT语句用于从表中查询数据。执行的结果被存储在一个结果表中(称为结果集)。语法格式如下：</p><pre><code class="hljs"> --这是注释 --从FROM指定的【表中】，查询出【所有的】数据。*表示【所有列】      SELECT * FROM 表名称 --从FROM指定的【表中】，查询出指定列名称(字段)的数据     SELECT 列名称 FROM 表名称 注意：SQL语句中的关键字对大小写不敏感。SELECT等效于select，FROM等效于from</code></pre></li><li><p>SELECT*示例</p><p> 我们希望从users表中选取所有的列，可以使用符号*取代列的名称，示例如下：</p><p> –注意：星号*是选取所有列的快捷方式</p><pre><code class="hljs"> SELECT * FROM users</code></pre></li><li><p>SELECT列名称示例</p><p> 如需取名”usename”和”password”的列的内容(从名为”users”的数据表)，请使用下面的SELECT语句：</p><p> –注意：多个列之间，使用英文逗号进行分隔</p><pre><code class="hljs"> SELECT username,password FROM users</code></pre></li></ol><p>4、SQL的INSERT INTO语句</p><ol><li><p>语法</p><p> INSERT INTO语句用于向数据表中插入新的数据行，语法格式如下：</p><pre><code class="hljs"> --语法解读：向指定的表中，插入如下几列数据，列的值通过 values---指定 注意：列和值要---对应，多个列和多个值之间，使用英文的逗号分隔 INSERT INTO table_name(列1,列2...)VALUES(值1，值2,...)</code></pre></li><li><p>INSERT INTO示例</p><p> 向users表中，插入一条username为tony stark，password为098123的用户数据，示例如下：</p></li></ol><p>5、SQL的UPDATE语句</p><ol><li><p>语法</p><p> Update语句用于修改表中的数据。语法格式如下：</p><pre><code class="hljs"> --语法解读： --1. 用UPDATE指定要更新哪个表中的数据 2. 用SET指定列对应的新值 3. 用WHERE指定更新的条件 UPDATE表名称SET列名称新值WHERE列名称=某值</code></pre></li><li><p>UPDATE示例-更新某一行中的一个列</p><p> 把users表中id为7的用户密码，更新为888888，示例如下</p></li><li><p>UPDATE示例-更新某一行中的若干列</p><p> 把users表中id为2的用户密码和用户状态，分别更新为admin123和1，示例如下：</p><pre><code class="hljs"> UPFATE users SET password=&#39;admin123&#39;,status=1 where id=2;</code></pre></li></ol><p>6、SQL的DELETE语句</p><ol><li><p>语法</p><p> DELETE语句用于删除表中的行。语法格式如下：</p><pre><code class="hljs"> --语法解读： --从指定的表中，根据WHERE条件，删除对应的数据行 DELETE FROM 表名称 WHERE 列名称 = 值</code></pre></li><li><p>DELETE示例</p><p> 从users表中，删除id为4的用户，示例如下：</p><pre><code class="hljs"> DELETE FROM users WHERE id=4;</code></pre></li></ol><p>7、SOL的WHERE子句</p><ol><li><p>语法</p><p> WHERE子句用于限定选择的标准。在SELECT、UPDATE、DELETE语句中，皆可使用WHERE子句来限定选择的标准</p><pre><code class="hljs"> --查询语句中的WHERE条件 SELECT 列名称 FROM 表名称 WHERE 列运算符 值 --更新语句中的WHERE条件 UPDATE 表名称 SET 列=新值 WHERE 列运算符 值 --删除语句中的WHERE条件 DELECT FROM 表名称 WHERE 列 运算符 值</code></pre></li><li><p>可在WHERE子句中使用的运算符</p><p> 下面的运算符可在WHERE子句中使用，用来限定选择的标准：</p><pre><code class="hljs"> 操作符          描述 =               等于 &lt;&gt;              不等于 &gt;               大于 &gt;               小于 &gt;=              大于等于 &lt;=              小于等于 BETWEEN         在某个范围内 LIKE            搜索某中格式 注意：在某些版本中的SQL中，操作符&lt;&gt;可以写为!=</code></pre></li><li><p>WHERE子句示例</p><p> 可以通过WHERE子句来限定SELECT的查询条件：</p><pre><code class="hljs"> --查询status为1的所有用户 SELECT * FROM users WHERE status=1; --查询id大于2的所有用户 SELECT * FROM users WHERE id&gt;2 --查询username不等于admin的所有用户 SELECT * FROM users WHERE username&lt;&gt;&#39;admin&#39;;</code></pre></li></ol><p>8、SQL的AND和OR运算符</p><ol><li><p>语法</p><p> AND和OR可在WHERE子语句中把两个或多个条件结合起来</p><p> AND表示必须同时满足多个条件，相当于JavaScript中的&amp;&amp;运算符，例如if(a!&#x3D;&#x3D;10&amp;&amp;a!&#x3D;&#x3D;20)</p><p> OR表示只要满足任意一个条件即可，相当于JavaScript中的||运算符，例如if(a!&#x3D;&#x3D;10||a!&#x3D;&#x3D;20)</p></li><li><p>AND运算符示例</p><p> 使用AND来显示所有status为0，并且id小于3的用户：</p></li><li><p>OR运算符示例</p><p>使用OR来显示所有status为1，或者username为zd的用户：</p></li></ol><p>9、SQL的ORDER BY子句</p><ol><li><p>语法</p><p> ORDER BY 语句用于根据指定的列对结果集进行排序</p><p> ORDER BY语句默认按照升序对记录进行排序</p><p> 如果您希望按照降序对记录进行排序，可以使用DESC关键字</p></li><li><p>ORDER BY子句-升序排序</p><p> 对users表中的数据，按照status字段进行升序排序，示例如下：</p></li><li><p>ORDER BY子句-降序排序</p><p> 对users表中的数据，按照id字段进行降序排序，示例如下：</p><pre><code class="hljs"> --注意：DESC代表降序排序 SELECT * FROM users ORDER BY id DESC;</code></pre></li><li><p>ORDER BY子句-多重排序</p><p> 对users表中的数据，先按照status字段降序排序，再按照username的子u顺序，进行升序排序，示例如下：</p></li></ol><p>10、SQL的COUNT(*)函数</p><ol><li><p>语法</p><p> COUNT(*)函数用于返回查询结果的总数居条数，语法格式如下：</p><pre><code class="hljs"> SELET COUNT(*) FROM 表名称</code></pre></li><li><p>COUNT(*)示例</p><p> 查询users表中status为0的总数据条数：</p></li><li><p>使用AS为列设置别名</p><p> 如果希望给查询出来的列名称设置别名，可以使用AS关键字，示例如下：</p></li></ol><p>四、在项目中操作MySQL</p><p>1、在项目中操作数据库的步骤</p><pre><code class="hljs">1. 安装操作MySQL数据库的第三方模块(mysql)2. 通过mysql模块连接到MySQL数据库3. 通过mysql模块执行SQL语句</code></pre><p>2、安装与配置mysql模块</p><ol><li><p>安装mysql模块</p><p> mysql模块是托管于npm上的第三方模块。它提供了在Node.js项目中连接和操作MySQL数据库的能力</p><p> 想要在项目中使用它，需要先运行如下命令，将mysql安装为项目的依赖包：</p><p> npm install mysql</p></li><li><p>配置mysql模块</p><p> 在使用mysql模块操作MySQL数据库之前，必须先对mysql模块进行必要的配置，主要的配置步骤如下：</p><pre><code class="hljs"> //1. 导入mysql模块 const mysql=require(&#39;mysql&#39;); //2. 建立与MySQL数据库的连接 const db=mysql.createPool(&#123;     host:&#39;127.0.0.1&#39;,//数据库的IP地址     user:&#39;root&#39;,     password:&#39;&#39;,//登录数据库的密码     database:&#39;my_db_01&#39;//指定要操作哪个数据库 &#125;)</code></pre></li><li><p>测试mysql模块能否正常工作</p><p> 调用db.query()函数，指定要执行的SQL语句，通过回调函数拿到执行的结果</p><pre><code class="hljs"> //检测mysql模块能否正常工作 db.query(&#39;SELECT 1&#39;,(err,results)=&gt;&#123;     if(err)&#123;         return console.log(err.message);     &#125;     console.log(results); &#125;)</code></pre></li></ol><p>3、使用mysql模块操作MySQL数据库</p><ol><li><p>查询数据</p><p> 查询users表中所有的数据</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//查询users表中所有的用户数据</span><br><span class="hljs-keyword">db</span>.<span class="hljs-keyword">query</span>(&#x27;select * from users&#x27;,(<span class="hljs-keyword">err</span>,results)=&gt;&#123;<br>    <span class="hljs-comment">//查询失败</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">err</span>)&#123;<br>        <span class="hljs-keyword">return</span> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">err</span>.message)<br>    &#125;<br>    <span class="hljs-comment">//查询成功</span><br>    console.<span class="hljs-built_in">log</span>(results);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>插入数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 要插入到users表中的数据对象</span><br><span class="hljs-keyword">const</span> user=&#123;<br>        <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;Spider-Man&#x27;</span>,<span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;pcc321&#x27;</span><br>&#125;<br><span class="hljs-comment">//2. 待执行的SQL语句，其中英文的??表示占位符</span><br><span class="hljs-keyword">const</span> sqlStr=<span class="hljs-string">&#x27;INSERT INTO uers (username,password) VALUES (?,?)&#x27;</span>;<br><span class="hljs-comment">//3. 使用数组的形式，依次为 ? 占位符指定具体的值</span><br>db.<span class="hljs-title function_">query</span>(sqlStr,[user.<span class="hljs-property">username</span>,user.<span class="hljs-property">password</span>],<span class="hljs-function">(<span class="hljs-params">err,results</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-property">message</span>)<span class="hljs-comment">//失败</span><br>    &#125;<br>    <span class="hljs-comment">//判断插入成功  </span><br>    <span class="hljs-keyword">if</span>(results.<span class="hljs-property">affecteRows</span>===<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入数据成功&#x27;</span>)<span class="hljs-comment">//成功</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>插入数据的便捷方式  </p><p> 向表中新增数据的时，如果数据对象的每个属性和数据表的字段–对应，则可以通知如下方式快速插入数据：</p><pre><code class="hljs"> //1. 要插入到users表中的数据对象 const user=&#123;username:&#39;Spider-Man2&#39;,password:&#39;pcc4321&#39;&#125;; //2. 待执行的SQL语句，其中英文的？表示占位符 const sqlStr=&#39;INSERT INTO usersSET ?&#39;; //3. 直接将数据对象当作占位符的值 db.query(sqlStr,user,(err,results)=&gt;&#123;     if(err)&#123;         return console.log(err.message)//失败     &#125;     if(results.affectedRows === 1)&#123;         console.log(&#39;插入数据成功&#39;)     &#125; &#125;)</code></pre></li><li><p>更新数据 </p><p> 可以通过如下方式，更新表中的数据</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//1. 要更新的数据对象</span><br><span class="hljs-keyword">const</span> user = &#123;id:7,username:&#x27;aaa&#x27;,password:&#x27;000&#x27;&#125;;<br><span class="hljs-comment">//2. 要执行的SQL语句</span><br><span class="hljs-keyword">const</span> sqlStr=&#x27;<span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> ? WHERE id=?&#x27;;<br><span class="hljs-comment">//3. 调用db.query()执行的SQL语句的同时，使用数组依次为占位符指定具体的值</span><br><span class="hljs-keyword">db</span>.<span class="hljs-keyword">query</span>(sqlStr,[user.username,user.password,user.id],(<span class="hljs-keyword">err</span>,results)=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">err</span>)&#123;<br>        <span class="hljs-keyword">return</span> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">err</span>.message);<span class="hljs-comment">//失败</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(results.affectedRows===1)&#123;<br>        console.<span class="hljs-built_in">log</span>(&#x27;更新数据成功！&#x27;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>更新数据的便捷方式</p><p> 更新表数据时，如果数据对象的每个属性和数据表的字段–对应，则可以通过如下方式快速更新表数据</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata">   <span class="hljs-comment">//1. 要更新的数据对象</span><br><span class="hljs-keyword">const</span> user = &#123;id:7,username:&#x27;aaa&#x27;,password:&#x27;000&#x27;&#125;;<br><span class="hljs-comment">//2. 要执行的SQL语句</span><br><span class="hljs-keyword">const</span> sqlStr=&#x27;<span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> ? WHERE id=?&#x27;;<br><span class="hljs-comment">//3. 调用db.query()执行的SQL语句的同时，使用数组依次为占位符指定具体的值</span><br><span class="hljs-keyword">db</span>.<span class="hljs-keyword">query</span>(sqlStr,[user,user.id],(<span class="hljs-keyword">err</span>,results)=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">err</span>)&#123;<br>        <span class="hljs-keyword">return</span> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">err</span>.message);<span class="hljs-comment">//失败</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(results.affectedRows===1)&#123;<br>        console.<span class="hljs-built_in">log</span>(&#x27;更新数据成功！&#x27;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li><p>删除数据</p><p> 在删除数据时，建议根据id这样的唯一标识，来删除对应的数据。示例如下：</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//1. 要执行的SQL语句</span><br><span class="hljs-keyword">const</span> sqlStr=&#x27;DELETE FROM users WHERE id=?&#x27;;<br><span class="hljs-comment">//2. 调用db.query()执行SQL语句的同时，为占位符制定具体的值</span><br><span class="hljs-comment">//注意：如果SQL语句中有多个占位符，则必须使用数组为每个占位符指定具体的值</span><br><span class="hljs-comment">//如果SQL语句只有一个占位符，则可以省略数组</span><br><br><span class="hljs-keyword">db</span>.<span class="hljs-keyword">query</span>(sqlStr,7,(<span class="hljs-keyword">err</span>,results)=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">err</span>)&#123;<br>        <span class="hljs-keyword">return</span> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">err</span>.message)<span class="hljs-comment">//失败</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(results.affectedRows===1)&#123;<br>        console.<span class="hljs-built_in">log</span>(&#x27;删除数据成功&#x27;)<span class="hljs-comment">//成功</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="7"><li><p>标记删除</p><p> 使用DELETE语句，会把真正的数据表从表中删除掉，为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。</p><p> 所谓的标记删除，就是在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除</p><p> 当用户执行了删除的动作时，我们并没有执行DELETE语句把数据删除掉，而是执行了UPDATE语句，将这条数据对应的status字段标记为删除即可</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//标记删除：使用UPDATE语句替代DELETE语句；只更新数据的状态，并没有真正删除</span><br><span class="hljs-keyword">db</span>.<span class="hljs-keyword">query</span>(&#x27;<span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">set</span> STATUS=1; WHERE ID=?&#x27;,6,(<span class="hljs-keyword">err</span>,results)=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">err</span>)&#123;<br>        <span class="hljs-keyword">return</span> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">err</span>.message)<span class="hljs-comment">//失败</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(results.affectedRows===1)&#123;<br>        console.<span class="hljs-built_in">log</span>(&#x27;删除数据成功&#x27;)<span class="hljs-comment">//成功</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>五、前后端的身份认证</p><p>1、Web开发模式</p><p>目前主流的Web开发模式有两种，分别是：</p><pre><code class="hljs">1. 基于服务端渲染的传统Web开发模式2. 基于前后端分离的新型Web开发模式</code></pre><ol><li><p>服务端渲染的Web 开发模式</p><p> 服务端渲染的概念：服务器发送给用户端的HTML页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用Ajax这样的技术额外请求页面的数据。代码示例如下</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">app.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;./index.html&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//1. 要渲染的数据</span><br>    <span class="hljs-keyword">const</span> user=&#123;name:<span class="hljs-string">&#x27;zs&#x27;</span>,age:<span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-comment">//2. 服务器端通过字符串的拼接，动态生成HTML内容</span><br>    <span class="hljs-keyword">const</span> html=<span class="hljs-string">&#x27;&lt;h1&gt;姓名：<span class="hljs-subst">$&#123;user.name&#125;</span>,年龄：<span class="hljs-subst">$&#123;user.age&#125;</span>&lt;/h1&gt;&#x27;</span>;<br>    <span class="hljs-comment">//3. 把生成好的页面内容响应给客户端，应此，客户都拿拿到的时带有正式数据的HTML页面</span><br>    res.send(html); <br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>服务端渲染的优缺点</p><p> 优点：</p><pre><code class="hljs"> 1. 前端耗时少。因为服务器端负责动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电。 2. 有利于SEO。因为服务器端响应的是完整的HTML页面内容，所有爬虫更容易获得信息，更有利于SEO</code></pre><p> 缺点：</p><pre><code class="hljs"> 1. 占用服务器端资源。及服务器完成HTML页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力 2. 不利于前后端分离，开发效率低。使用服务端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发</code></pre></li><li><p>前后端分离的Web开发模式</p><p> 前后端分离的概念：前后端分离的开发模式，依赖于Ajax技术的广泛应用，简而言之，前后端分离的Web开发模式，就是后端只负责API接口，前端使用Ajax调用接口的开发模式</p></li><li><p>前后端分离的优缺点</p><p> 优点：</p><pre><code class="hljs"> 1. 开发体验好。前端专注于UI页面的开发，后端专注于api的开发，且前端有跟多的选择性。 2. 用户体验好。Ajax技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新 3. 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的</code></pre><p> 缺点：</p><pre><code class="hljs"> 1. 有利于SEO。因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。(解决方案：利用Vue、React等前端框架的SSR(server side render)技术能够很好的解决SEO问题)</code></pre></li><li><p>如何选择Web开发模式</p><p> 不谈业务场景而盲目选择使用何种开发模式都是耍流氓</p><p> 比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；</p><p> 而类似于后台管理项目，交互性比较强，不需要考虑SEO，那么就可以使用前后端分离的开发模式</p><p> 另外，具体使用何种开发模式并不是绝对的，为了同时依赖了首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器渲染+其他页面前后端分离的开发模式</p></li></ol><p>2、身份认证</p><ol><li><p>什么是身份认证</p><p> 身份认证(Authentication)又称’身份验证’、’鉴权’，是指通过一定的手段，完成对用户身份的确认</p><pre><code class="hljs"> 日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或者指纹解锁，支付宝或微信的支付密码等  在Web开发中，也涉及到用户身份的认证，例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等。</code></pre></li><li><p>为什么需要身份认证</p><p> 省份认证的目的，是为了确认当前声称为某种身份的用户，确实是所声称的用户。例如，你去找快递员取快递，你要怎么证明这份快递是你的</p><p> 在互联网项目开发中，如何对用户身份进行认证，是一个值得深入探讨的问题，例如，如何才能保证网站不会错误的将’马云的存款数额’显示到’马化腾的账户’上</p></li><li><p>不同开发模式下的身份认证</p><p> 对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p><pre><code class="hljs"> 1. 服务端渲染推荐使用Session认证机制 2. 前后端分离推荐使用JWT认证机制</code></pre></li></ol><p>3、Session认证机制</p><ol><li><p>HTTP协议的无状态性</p><p> 了解HTTP协议的无状态性进一步学习Session认证机制的必要前提</p><p> HTTP协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态</p></li><li><p>如何突破HTTP无状态的限制</p><p> 对于超市来说，为了方便收银员在进行结算时给VIP用户打折，超市可以为每个VIP用户发放会员卡</p><pre><code class="hljs"> 注意：现实生活中的会员卡身份认证方式，在Web开发中的专业术语叫做Cookie</code></pre></li><li><p>什么是Cookie</p><p> Cookie是存储在用户浏览器中的一段不超过4kb的字符串，它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成</p><p> 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器</p><p> Cookie的几大特性：</p><pre><code class="hljs"> 1. 自动发送 2. 域名独立 3. 过期时限 4. 4kb限制</code></pre></li><li><p>Cookie在身份认证中的作用</p><p> 客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中。</p><p> 随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份</p></li><li><p>Cookie不具有安全性</p><p> 由于Cookie时存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易伪造，不具有安全性。因此不建议服务器将重要的隐私数据，通过Cookie的形式发送给浏览器</p><pre><code class="hljs"> 注意：前往不要使用Cookie存储重要且隐私的数据！比如用户的身份信息、密码等</code></pre></li><li><p>提高身份认证的安全性</p><p> 为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡认证，只有收音机确认存在的会员卡，才能被正常使用</p></li><li><p>Session的工作机制</p></li></ol><p>4、在Express中使用Session认证</p><ol><li><p>安装express-session中间件</p><p> 在Express项目中，只需要安装express-session中间件，即可在项目中使用Session认证</p></li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> express-session<br></code></pre></td></tr></table></figure><ol start="2"><li><p>配置express-session中间件</p><p> express-session中间件安装成功后，需要通过app.use()来注册session中间件，示例代码如下</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>. 导入session中间件<br>var session=require(<span class="hljs-string">&#x27;express-session&#x27;</span>);<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 配置session中间件<br>app.use(session(&#123;<br>    secret:<span class="hljs-string">&#x27;keyboard cat&#x27;</span>,<span class="hljs-regexp">//</span>secret属性的值可以任意字符串<br>    resave:false,<span class="hljs-regexp">//</span>固定写法<br>    saveUninitialized:true<span class="hljs-regexp">//</span>固定写法<br>&#125;))<br></code></pre></td></tr></table></figure><ol start="3"><li><p>向session中存数据</p><p> 当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php">app.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//判断用户提交的登录信息是否正确</span><br>    <span class="hljs-keyword">if</span>(req.body.username!==<span class="hljs-string">&#x27;admin&#x27;</span>||req.body.password!==<span class="hljs-string">&#x27;000000&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_ invoke__">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录失败&#x27;</span>&#125;)<br>    &#125;<br>    req.session.user=req.body<span class="hljs-comment">//将用户的信息，存储到Session中</span><br>    req.session.islogin=<span class="hljs-literal">true</span><span class="hljs-comment">//将用户的登录状态，存储到Session中</span><br>    res.<span class="hljs-title function_ invoke__">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录成功&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li><p>从session中取数据</p><p> 可以直接从req.session对象上获取之前存储的数据，示例代码如下：</p></li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//获取用户姓名的接口</span><br>app<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//判断用户是否登录</span><br>    <span class="hljs-built_in">if</span>(!req<span class="hljs-selector-class">.session</span>.islogin)&#123;<br>        return res<span class="hljs-selector-class">.send</span>(&#123;status:<span class="hljs-number">1</span>,msg:<span class="hljs-string">&#x27;fail&#x27;</span>&#125;)<br>    &#125;<br>    res<span class="hljs-selector-class">.send</span>(&#123;status:<span class="hljs-number">0</span>,msg:<span class="hljs-string">&#x27;success&#x27;</span>,username:req<span class="hljs-selector-class">.session</span><span class="hljs-selector-class">.user</span>.username&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>清空session</p><p> 调用req.session.destroy()函数，即可清空服务器保存的session信息</p></li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//退出登录的接口</span><br>app<span class="hljs-selector-class">.post</span>(<span class="hljs-string">&#x27;/api/logout&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//清空当前客户端对应的session信息</span><br>    req<span class="hljs-selector-class">.session</span><span class="hljs-selector-class">.destroy</span>()<br>    res<span class="hljs-selector-class">.send</span>(&#123;<br>        status:<span class="hljs-number">0</span>,<br>        msg:<span class="hljs-string">&#x27;退出登陆成功&#x27;</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>5、JWT认证机制</p><ol><li><p>了解Session认证机制的局限性</p><p> Session认证机制需要Cookie才能实现。由于Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证</p><p> 注意：</p><pre><code class="hljs"> 当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制 当前端需要跨域请求后端接口的时候，不推荐使用Session省份认证机制，推荐使用JWT认证机制</code></pre></li><li><p>什么是JWT</p><p> JWT(英文全称：JSON Web Token)是目前最流行的跨域认证解决方案</p></li><li><p>JWT的工作原理</p><p> 总结：用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份</p></li><li><p>JWT组成部分</p><p> JWT通常由三部分组成，分别是Header(头部)、Payload(有效荷载)、Signature(签名)</p><p> 三者之间使用英文的”.”分隔，格式如下：</p><pre><code class="hljs"> Header.Payload.Signature</code></pre><p> 下面是JWT字符串的示例：</p></li><li><p>JWT的三个部分各自代表的含义</p><p> JWT的三个组成部分，从前到后分别是Header、Payload、Signature</p><p> 其中：</p><pre><code class="hljs"> Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串 Header和Signature是安全性相关的部分，只是为了保证Token的安全性</code></pre></li><li><p>JWT的使用方式</p><p> 客户端收到服务器返回的JWT之后，通常会将它储存在localStorage或sessionStorage中</p><p> 此后。客户端每次于服务器通信，都要带上这个JWT的字符串，从而进行身份认证。推荐的做法是把JWT放在HTTP请求头的Authorization字段中，格式如下：</p><pre><code class="hljs"> Authorization：Bearer&lt;token&gt;</code></pre></li></ol><p>6、在Express中使用JWT</p><ol><li><p>安装JWT相关的包</p><p> 运行如下命令，安装如下两个JWT相关的包：</p></li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jsonwebtoken </span>express-<span class="hljs-keyword">jwt</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">其中：    jsonwebtoken用于生成JWT字符串    express-jwt用于将JWT字符串解析还原成JSON对象</code></pre><ol start="2"><li><p>导入JWT相关的包</p><p> 使用require()函数，分别导入JWT相关的两个包：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 导入用于生成JWT字符串的包</span><br><span class="hljs-keyword">const</span> jwt=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>);<br><span class="hljs-comment">//2. 导入用于将客户端发送过来的JWT字符串，解析还原成JSON对象的包</span><br><span class="hljs-keyword">const</span> expressJWT=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li><p>定义secret密钥</p><p> 为了保证JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人拨接，我们需要专门定义一个用于加密和解密的secret密钥：</p><pre><code class="hljs"> 1. 当生成JWT字符串的时候，需要使用sercret密钥对用户的信息进行加密，最终得到加密好的JWT字符串 2. 当把JWT字符串解析还原JSON对象的时候，需要使用secret密钥进行解密</code></pre></li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">//3. secret密钥的本质：就是一个字符串</span><br><span class="hljs-keyword">const</span> secretKey=<span class="hljs-string">&#x27;itheima No ^_^&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>在登录成功后生成JWT字符串</p><p> 调用jsonwebtoken包提供的sign()方法，将用户的信息加密成JWT字符串，响应给客户端</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>登录接口<br>app.post(<span class="hljs-string">&#x27;/api/login&#x27;</span>,<span class="hljs-keyword">function</span>(req,res)&#123;<br>    <span class="hljs-regexp">//</span>...省略登录失败情况下的代码<br>    <span class="hljs-regexp">//</span>用户登陆成功之后，生成JWT字符串，通过token属性响应给客户端<br>    res.send(&#123;<br>        status:<span class="hljs-number">200</span>,<br>        message:<span class="hljs-string">&#x27;登陆成功！&#x27;</span>,<br>        <span class="hljs-regexp">//</span>调用jwt.sign()生成jwt字符串，三个参数分别是：用户信息对象、加密密钥、配置对象<br>        token:jwt.sign(&#123;username:userinfo.username&#125;,secretKey,&#123;expiresIn:<span class="hljs-string">&#x27;30s&#x27;</span>&#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>将JWT字符串还原为JSON对象</p><p> 客户端每次在访问那些有权限接口的时候，都需要主动请求头中的Authorization字段，将Token字符串发送到服务器身份认证</p><p> 此时，服务器可以通过express-jwt这个中间件，自动将客户端发送过来的Token解析还原成JSON对象：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>使用app.use()来注册中间件<br><span class="hljs-regexp">//</span>expressJWT(&#123;secret:secretKey&#125;)就是来用解析Token的中间件<br><span class="hljs-regexp">//</span>.unless(&#123;path:[<span class="hljs-regexp">/^\/api\//</span>]&#125;)用来指定那些接口不需要访问权限<br>app.use(expressJWT(&#123;secret:secretKey&#125;).unless(&#123;path:[<span class="hljs-regexp">/^\api\//</span>]&#125;))<br></code></pre></td></tr></table></figure><ol start="6"><li><p>使用req.user获取用户信息</p><p> 当express-jwt这个中间件配置成功之后，即可在那些有权限的接口中，使用req.user对象，来访问从JWT字符串中解析出来的用户信息了，示例代码如下：</p></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">//这是有权限的API接口<br>app.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;/admin/getinfo&#x27;</span>,<span class="hljs-keyword">function</span>(req,<span class="hljs-keyword">res</span>)&#123;<br>    console.<span class="hljs-built_in">log</span>(req.user)<br>    <span class="hljs-keyword">res</span>.send(&#123;<br>        statu<span class="hljs-variable">s:200</span>,<br>        message:<span class="hljs-string">&#x27;获取用户信息成功！&#x27;</span>,<br>        dat<span class="hljs-variable">a:req</span>.user<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="7"><li><p>捕获解析JWT失败后产生的错误</p><p> 当使用express-jwt解析Token字符串时，如果客户端发送过来的Token字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。我们通过Express的错误中间件，捕获这个错误并进行相关的处理，示例代码如下：</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">app.<span class="hljs-keyword">use</span>((err,req,res,next)=&gt;&#123;<br>    <span class="hljs-comment">//token解析失败导致的错误</span><br>    <span class="hljs-keyword">if</span>(err.name===<span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_ invoke__">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">401</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;无效的token&#x27;</span>&#125;)<br>    &#125;<br>    <span class="hljs-comment">//其它原因导致的错误</span><br>    res.<span class="hljs-title function_ invoke__">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">500</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;未知错误&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="http://escook.cn:8088/#/">在线开发文档项目</a></p><p>具体项目内容看api_server文件夹</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6</title>
    <link href="/2023/02/17/ES6/"/>
    <url>/2023/02/17/ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="ES介绍"><a href="#ES介绍" class="headerlink" title="ES介绍:"></a>ES介绍:</h1><p>ES全称EcmaScript，是脚本语言的规范，而平时经常编写的javascript，是EcmaScript的一种实现，所以ES新特性其实指的就是JavaScript的新特性。</p><span id="more"></span><h2 id="ECMAScript相关介绍"><a href="#ECMAScript相关介绍" class="headerlink" title="ECMAScript相关介绍"></a>ECMAScript相关介绍</h2><p>1、 什么是ECMA</p><ul><li>ECMA(European Computer Manufacturers Aessociation)中文名称称为计算机制造协会，这个组织的目标是评估、开发和认可电信和计</li></ul><p>2、什么是ECAMAScript</p><ul><li>ECMAScript是由Ecma国际通过ECMA-262标准化的脚本程序设计语言</li></ul><p>3、什么是ECMA-262</p><ul><li>Ecma国际制定了许多标准，而ECMA-262只是其中一个，所有标准自己查</li></ul><p>4、ECMA-262历史</p><ul><li>Ecma-262(ECMAScript)历史版本查看网址</li></ul><p>5、谁在维护ECMA-262</p><ul><li>TC39(Technical Commitee 39)是推进ECMAScript发展的委员会。其会员都是公司(其中主要是浏览器厂商，有苹果、谷歌、微软、英特尔)。TC39定期召开会以，会议由会员公司的代表与特邀专家出席</li></ul><p>6、为什么要学习ES6</p><ul><li>ES6的版本变动内容最多，具有里程碑意义</li><li>ES6加入许多新的语法特性，编程实现更简单、高效</li><li>ES6是前端发展趋势，就业必备技能</li></ul><p>7、ES6兼容性</p><ul><li><a href="http://kangax.github.io/compat-table/es6/">可查看兼容性</a></li></ul><h2 id="let特性"><a href="#let特性" class="headerlink" title="let特性"></a>let特性</h2><ol><li>变量不能重复声明</li><li>块级作用域 全局，函数，eval(es5的严格模式里才会出现)</li><li>不存在变量提升</li><li>不影响作用域链</li></ol><h2 id="const定义常量特性"><a href="#const定义常量特性" class="headerlink" title="const定义常量特性"></a>const定义常量特性</h2><ol><li>一定要赋初始值</li><li>一般常量使用大写(潜规则)</li><li>常量的值不能修改</li><li>块级作用域</li><li>对于数组和对象的元素修改，不算做对常量的修改，不会报错</li></ol><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值这被称为结构数组</p><ol><li>数组的结构</li><li>对象的结构</li></ol><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>ES6引入新的声明字符串的方式[&#96;&#96;] ‘’ “”</p><ol><li><p>声明</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span>=`我也是一个字符串哦！`;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>,typeof <span class="hljs-built_in">str</span>);<br></code></pre></td></tr></table></figure></li><li><p>内容中可以直接出现换行符</p></li><li><p>变量的拼接</p></li></ol><h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><p>ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法<br>这样的书写更加简洁</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6允许使用<a href="=%3E">箭头</a>定义函数</p><ol><li><p>this是静态的，this始终指向函数声明时所在作用域下的this的值<br>call方法调用</p></li><li><p>不能作为构造函数实例化对象</p></li><li><p>不能使用arguments变量<br> (1)省略小括号，当形参有且只有一个的时候</p> <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let add=<span class="hljs-function"><span class="hljs-params">n</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> n+n;<br>&#125;<br></code></pre></td></tr></table></figure><p> console.log(add(9));<br> (2)省略花括号，当代码体只有一条语句的时候,此时return必须省略而且语句的执行结果就是函数的返回值<br> let pow&#x3D;(n)&#x3D;&gt;n*n;</p><p> filter函数(筛选函数)</p><p> 箭头函数适合于this无关的回调，定时器的方法回调<br> 箭头函数不适合于this有关的问题，事件回调，对象的方法</p></li></ol><h2 id="ES6允许给函数参数值赋值初始值"><a href="#ES6允许给函数参数值赋值初始值" class="headerlink" title="ES6允许给函数参数值赋值初始值"></a>ES6允许给函数参数值赋值初始值</h2><ol><li><p>形参初始值</p></li><li><p>与结构赋值结合</p></li></ol><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6引入rest参数，用于获取函数的实参，用来代替arguments之前ES5获取实参的方式</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">date</span><span class="hljs-params">()</span>&#123;<br>    console.log(argument);返回的是对象<br>&#125;<br>date(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br><br><span class="hljs-comment">//rest参数(...args)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">date</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span>&#123;<br>    console.log(<span class="hljs-string">&#x27;args&#x27;</span>);<span class="hljs-comment">//返回的是数组有利于filter some every map</span><br>&#125;<br>date(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br><br><span class="hljs-comment">//rest 参数必须放到参数最后</span><br></code></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><ol><li><p>[…]扩展运算符能将[数组]转换为逗号分隔的[参数序列]<br>声明一个数组</p></li><li><p>扩展运算符的应用<br>(1)数组的合并<br>concat()方法(拼接数组)</p></li></ol><p>(2)数组的克隆<br>(3)将为数组转为真正的数组 </p><h2 id="Symbol基本使用"><a href="#Symbol基本使用" class="headerlink" title="Symbol基本使用"></a>Symbol基本使用</h2><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，它是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型</p><p>Symbol特点<br>(1)Symbol的值是唯一的，用来解决命名冲突的问题<br>(2)Symbol值不能与其他数据进行运算<br>(3)Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript">    <span class="hljs-comment">//创建Symbol</span><br>    <span class="hljs-keyword">let</span> s=<span class="hljs-title class_">Symbol</span>();<br>    <span class="hljs-keyword">let</span> s2=<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;尚硅谷&#x27;</span>);<br>    <span class="hljs-keyword">let</span> s3=<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;尚硅谷&#x27;</span>);<br>    <span class="hljs-comment">//Symbol.for创建</span><br>    <span class="hljs-keyword">let</span> s4=<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>();<span class="hljs-comment">//重复创建一样</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s2===s3);<span class="hljs-comment">//返回false</span><br><br>    <span class="hljs-comment">//不能与其他数据进行运算</span><br>    <span class="hljs-variable constant_">USONB</span>=you are so niubility<br>    u <span class="hljs-literal">undefined</span><br>    s <span class="hljs-built_in">string</span> <span class="hljs-built_in">symbol</span><br>    o <span class="hljs-built_in">object</span> <br>    n <span class="hljs-literal">null</span> <span class="hljs-built_in">number</span><br>    b <span class="hljs-built_in">boolean</span><br><br><span class="hljs-title class_">Symbol</span>的使用<br><br><span class="hljs-comment">//给对象添加属性和方法up down</span><br><span class="hljs-keyword">let</span> youxi=&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;sd&#x27;</span>,<br>    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;say&#x27;</span>)]:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以发言&#x27;</span>);<br>    &#125;,<br>    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;zobao&#x27;</span>)]:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以自爆&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(youxi);<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Symbol内置值(自己搜)    除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器(itertor)是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作</p><p>(1)ES6创造了一种新的遍历命令for…of循环 ，Iterator接口主要供for…of消费<br>(2)原生具备iterator接口的数据(可用for of遍历)</p><ul><li>(a)Array</li><li>(b)Arguments</li><li>(c)Set</li><li>(d)Map</li><li>(e)String</li><li>(f)TypedArray</li><li>(g)NodeList</li></ul><p>(3)工作原理</p><p>(a)创建一个指针对象，指向当前数据结构的起始位置<br><br>(b)第一次调用对象的next方法，指针自动指向数据结构的第一个成员<br><br>(c)接下来不断调用next方法，指针一致往后移，直到指向最后一个成员<br><br>(d)每调用next()方法返回一个包含value和done属性的对象</p><ul><li>注意：需要自定义遍历数据的时候，要想迭代器</li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器其实就是一个特殊字符<br>异步编程 纯回调函数 node fs ajax mongodb</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> * <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;<br>用next来控制向下执行(可用传入实参)<br><br><span class="hljs-comment">//异步编程，文件操作 网络操作(ajax,request)数据库操作</span><br></code></pre></td></tr></table></figure><h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><p>1、 实例化Promise对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//实例化Promise对象</span><br><span class="hljs-keyword">const</span> p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//let data=&#x27;数据库中的用户数据&#x27;;</span><br>        <span class="hljs-title function_">resove</span>(data);<br>        <span class="hljs-keyword">let</span> err =<span class="hljs-string">&#x27;数据读取失败&#x27;</span>;<br>        <span class="hljs-title function_">reject</span>(err);<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;);<br><span class="hljs-comment">//调用promise对象的then方法(指定回调)</span><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><p>Promise读取文件</p><ol><li>引入fs模块<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const fs</span>=require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>调用方法读取文件<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File(&#x27;.<span class="hljs-operator">/</span><span class="hljs-params">resources</span><span class="hljs-operator">/</span>为学.<span class="hljs-params">md</span>&#x27;,(<span class="hljs-params">err</span>,<span class="hljs-params">data</span>)</span>=&gt;&#123;<br>    <span class="hljs-comment">//如果失败，则抛出错误</span><br>    <span class="hljs-keyword">if</span>(err)throw err;<br>    <span class="hljs-comment">//如果没有出错，则输出内容</span><br>    看内容用tostring<br>    console.log(data.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li>使用Promise封装<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;路径地址&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//判断如果失败</span><br>        <span class="hljs-keyword">if</span>(err)<span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-comment">//如果成功</span><br>        <span class="hljs-title function_">resolve</span>(data);<br>    &#125;)<br>&#125;)<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">tostring</span>());<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败！！&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h2 id="Promise封装AJAX请求"><a href="#Promise封装AJAX请求" class="headerlink" title="Promise封装AJAX请求"></a>Promise封装AJAX请求</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//用promise</span><br><span class="hljs-keyword">const</span> p =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//1. 创建对象</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">//2. 初始化</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://api.apiopen.top/getJoke&quot;</span>);<br><span class="hljs-comment">//3. 发送</span><br>xhr.<span class="hljs-title function_">send</span>();<br><span class="hljs-comment">//4. 绑定事件，处理响应结果</span><br>xhr.<span class="hljs-property">onreadystatechange</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//判断</span><br>    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span>===<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-comment">//判断响应状态码200-299</span><br>        <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span>&gt;=&amp;&amp;xhr.<span class="hljs-property">status</span>&lt;<span class="hljs-number">300</span>)&#123;<br>            <span class="hljs-comment">//表示成功</span><br>            <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">response</span>);   <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//如果失败</span><br>            <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">status</span>);<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;)<br><span class="hljs-comment">//指定回调</span><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>2、promise.prototype..then方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    <span class="hljs-comment">//创建promise对象</span><br>    <span class="hljs-keyword">const</span> p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>((=&gt;&#123;<br>            <span class="hljs-comment">//resolve(&#x27;用户数据&#x27;);</span><br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>        &#125;,<span class="hljs-number">1000</span>)<br>    &#125;);<br>    <span class="hljs-comment">//调用then方法 then方法的返回结果是Promise对象，对象状态由回调函数的执行结果决定</span><br>    <span class="hljs-comment">//1. 如果回调函数中返回的结果是 非promise类型,状态成功，返回值为对象的成功的值</span><br>    <span class="hljs-keyword">const</span> result=p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>        <span class="hljs-comment">//1. 非promise类型的属性</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;iloveyou&#x27;</span>;<br>        <span class="hljs-comment">//2. 是promise对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;);<br>        <span class="hljs-comment">//3. 抛出错误</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;出错啦！&#x27;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;,<span class="hljs-function"><span class="hljs-params">reson</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(reason);<br>    &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br></code></pre></td></tr></table></figure><h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>声明一个set<br><span class="hljs-regexp">//</span>检测数组<br>let s=new Set();<br><span class="hljs-regexp">//</span>元素个数<br>s.size;<br><span class="hljs-regexp">//</span>添加新的元素<br>s.add()<br><span class="hljs-regexp">//</span>删除元素(去除选中的元素)<br>s.<span class="hljs-keyword">delete</span>()<br><span class="hljs-regexp">//</span>检测(检查数组中是否有，有则返回ture，否则返回false)<br>s.has()<br><span class="hljs-regexp">//</span>清空<br>s.clear();<br><span class="hljs-regexp">//</span>可以使用<span class="hljs-keyword">for</span>...of 循环遍历<br><span class="hljs-regexp">//</span>可以使用[...]扩展符<br><br>Set实践<br>let arr[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><ol><li>数组去重<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> result=<span class="hljs-meta">[</span><span class="hljs-params">...</span><span class="hljs-literal">new</span> <span class="hljs-built_in">Set</span>(arr)<span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure></li><li>交集<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr2=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> result=[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr2);<span class="hljs-comment">//4 5 6先去重</span><br>    <span class="hljs-keyword">if</span>(s2.<span class="hljs-title function_">has</span>(item))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//简写</span><br><span class="hljs-keyword">let</span> result=[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr2).<span class="hljs-title function_">has</span>(item));<br></code></pre></td></tr></table></figure></li><li>并集<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> union=<span class="hljs-meta">[</span><span class="hljs-params">...</span><span class="hljs-literal">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-meta">[</span><span class="hljs-params">...</span>arr,<span class="hljs-params">...</span>arr2<span class="hljs-meta">]</span>)];//先合并然后去重再转换为数组<br></code></pre></td></tr></table></figure></li><li>差集<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> diff=[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>!(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr2).<span class="hljs-title function_">has</span>(item)));<br></code></pre></td></tr></table></figure></li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是’键’的范围不限于字符串，各种类型的值(包括对象)都可以当作键。Map也实现了iterator接口，所以可以使用[扩展运算符]和[for…of…]进行遍历。Map的属性和方法</p><ol><li>size 返回Map的元素个数</li><li>set 增加一个新元素，返回当前Map(Set 一个用法)</li><li>get 返回键名对象的键值</li><li>has 检测Map中是否包含某个元素，返回boolean值</li><li>clear 清空集合，返回undefined<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建一个空map<br>let m =new Map();<br><span class="hljs-regexp">//</span>创建一个非空map<br><br><span class="hljs-regexp">//</span>删除<br>m.<span class="hljs-keyword">delete</span>();<br><span class="hljs-regexp">//</span>获取<br>m.get()<span class="hljs-regexp">//</span>对应键值<br><span class="hljs-regexp">//</span>清空<br>m.clear();<br><span class="hljs-regexp">//</span>遍历<br></code></pre></td></tr></table></figure></li></ol><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><p>1、ES6提供了更接近传统语言的写法，引入了Class(类)这个概念，作为对象的模板。通过class关键字，可以定义类。<br>基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象的语法而已</p><p>知识点：</p><ol><li>class声明类</li><li>constructor定义构造函数初始化</li><li>extends继承父类</li><li>super调用父级构造方法</li><li>static定义静态方法和属性</li><li>父类方法可以重写<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shouji</span> &#123;<br>    <span class="hljs-comment">//构造函数 名字不能修改</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brand,price</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span>=brand;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span>=price;<br>    &#125;<br>    <span class="hljs-comment">//方法必须使用该语法，不能使用ES5的对象完整形式</span><br>    <span class="hljs-title function_">call</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> onPlus=<span class="hljs-keyword">new</span> <span class="hljs-title function_">shouji</span>(<span class="hljs-string">&quot;1+&quot;</span>,<span class="hljs-number">1999</span>);<br></code></pre></td></tr></table></figure>2、静态成员<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-comment">//静态属性</span><br>    <span class="hljs-keyword">static</span> name=<span class="hljs-string">&#x27;手机&#x27;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以改变世界&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> nokia =<span class="hljs-keyword">new</span> <span class="hljs-title function_">phone</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nokia.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Phone</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure>3、对象继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brand,price</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span>=brand;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span>=price;<br>    &#125;<br>    <span class="hljs-comment">//父类的成员属性</span><br>    <span class="hljs-title function_">call</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以打电话！！&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Phone</span>&#123;<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brand,price,color,size</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(brand,price);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>=color;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>=size;<br>    &#125;<br>    <span class="hljs-title function_">photo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;拍照&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">playGame</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;玩游戏&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> xiaomi =<span class="hljs-keyword">new</span> <span class="hljs-title class_">SmartPhone</span>(<span class="hljs-string">&#x27;小米&#x27;</span>,<span class="hljs-number">799</span>，<span class="hljs-string">&#x27;黑色&#x27;</span>,<span class="hljs-string">&#x27;4.7inch&#x27;</span>);<br></code></pre></td></tr></table></figure>4、get和set<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">price</span>()&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;价格属性被读取了&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;iloveyou&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">price</span>(<span class="hljs-params">newvalue</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;价格属性被修改了&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实例化对象</span><br><span class="hljs-keyword">let</span> s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br></code></pre></td></tr></table></figure></li></ol><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ol><li><p>Number.EPSILON是JavaScript表示的最小精度<br> &#x2F;&#x2F;EPSILON属性的接近于2.220446049250310808472633361816E-16</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">equal</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">if</span>(Math.<span class="hljs-built_in">abs</span>(a-b)&lt; <span class="hljs-built_in">Number</span>.EPSILON)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二进制和八进制</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> b=<span class="hljs-number">0b1010</span>;//<span class="hljs-number">0b</span>表示二进制<br><span class="hljs-built_in">let</span> o=<span class="hljs-number">0o777</span>;//表示八进制<br><span class="hljs-built_in">let</span> d=<span class="hljs-number">100</span>;//表示十进制<br><span class="hljs-built_in">let</span> x=<span class="hljs-number">0xff</span>;//十六进制<br></code></pre></td></tr></table></figure></li><li><p>Number.isFinite检测一个数值是否为有限数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">100</span>)//<span class="hljs-literal">true</span><br><span class="hljs-built_in">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">100</span>/<span class="hljs-number">0</span>)//<span class="hljs-literal">false</span><br><span class="hljs-built_in">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">Infinity</span>)//<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>Number.isNaN检测一个数值是否为NaN</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>)<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li><li><p>Number.parseInt Number.parseFloat字符串转整数</p></li><li><p>Number.isInteger判断一个数是否为整数</p></li><li><p>Math.trunc将数字的小数部分抹掉</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Math</span>.trunc(<span class="hljs-number">3</span>.<span class="hljs-number">5</span>)//<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li><li><p>Math.sign判断一个数到底为正数 负数 还是零</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Math</span>.sign(<span class="hljs-number">100</span>)//<span class="hljs-number">1</span><br><span class="hljs-attribute">Math</span>.sign(<span class="hljs-number">0</span>)//<span class="hljs-number">0</span><br><span class="hljs-attribute">Math</span>.sign(-<span class="hljs-number">20000</span>)//-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="对象方法的扩展"><a href="#对象方法的扩展" class="headerlink" title="对象方法的扩展"></a>对象方法的扩展</h2><ol><li>Object.is判断两个值是否完全相等</li><li>Object.assign对象的合并</li><li>Object.setPrototypeOf Object.getPrototypeof</li></ol><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol><li><p>概念:<br> 模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来</p></li><li><p>模块化的好处<br> 模块化的优势有以下几点：</p><ul><li>防止命名冲突</li><li>代码复用</li><li>高维护性</li></ul></li><li><p>模块化规范产品<br> ES6之前的模块化规范有：</p><ul><li>CommonJS &#x3D;&gt;NodeJS、Browserify</li><li>AMD      &#x3D;&gt;requireJS</li><li>CMD      &#x3D;&gt;seaJS</li></ul></li><li><p>ES6模块化语法<br> 模块功能主要有两个命令构成：export和import</p><pre><code class="hljs"> export命令用于规定模块的对外接口 import命令用于输入其他模块提供的概念</code></pre></li></ol><h2 id="ES6-babel对ES6模块化代码转换"><a href="#ES6-babel对ES6模块化代码转换" class="headerlink" title="ES6-babel对ES6模块化代码转换"></a>ES6-babel对ES6模块化代码转换</h2><ol><li><p>安装工具 babel-cli babel-preset-env browserify(webpack)</p></li><li><p>通过npx babel src&#x2F;js -d dist&#x2F;js转换</p></li><li><p>打包npx browserify dist&#x2F;js&#x2F;app.js -o dist&#x2F;bundle.js</p></li></ol><h2 id="ES6模块化引入NPM包"><a href="#ES6模块化引入NPM包" class="headerlink" title="ES6模块化引入NPM包"></a>ES6模块化引入NPM包</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jQuery&#x27;</span>;<span class="hljs-comment">//导入jquery包</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node</title>
    <link href="/2023/02/17/node/"/>
    <url>/2023/02/17/node/</url>
    
    <content type="html"><![CDATA[<h1 id="node介绍："><a href="#node介绍：" class="headerlink" title="node介绍："></a>node介绍：</h1><p>node是一个JS运行环境，一个用chrome浏览器V8引擎来跑JS代码的环境。</p><!-- 文章页卡片展示文本 --><span id="more"></span><h2 id="初识Node-js"><a href="#初识Node-js" class="headerlink" title="初识Node.js"></a>初识Node.js</h2><p>1、回顾与思考</p><ol><li><p>浏览器中的JavaScript的组成部分？</p><p> JS核心语法          WebAPI<br> 变量、数据类型      DOM操作<br> 循环、分支、判断    BOM操作<br> 函数、作用域、this  基于XMLHttpRequest的Ajax操作<br> etc…              etc…</p></li><li><p>思考：为什么JavaScript可以在浏览器中被执行？</p><p> 因为有JavaScript解析引擎(不同浏览器的解析引擎不同，从而出现差异，其中谷歌最好)</p></li><li><p>思考：为什么JavaScript可以操作DOM和BOM？</p><p> 因为每个浏览器都内置了DOM、BOM这样的APL函数，因此，浏览器中的JavaScript才可以调用它们</p></li><li><p>思考：浏览器中的JavaScript运行环境(指正常运行所必需的必要环境)</p><p> 因为：</p><p> 1 V8引擎负责解析和执行JavaScript代码</p><p> 2 内置API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用</p></li><li><p>思考：JavaScript能否做后端开发？(常见的Java、python、PHP等后端语言)</p><p> 可以，但是需要node.js来进行后端开发的运行环境</p></li></ol><p>2、 node.js简介</p><ol><li><p>什么是Node.js？</p><p> Node.js是一个基于Chrome V8引擎的JavaScript运行环境<br> node.js的官方地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p></li><li><p>Node.js中的JavaScript运行环境</p><p> 1 浏览器是JavaScript的前端运行环境<br> 2 Node.js是JavaScript的后端运行环境<br> 3 Node.js中无法调用DOM和BOM等浏览器内置API</p></li><li><p>Node.js可以做什么？</p><p> Node.js作为一个JavaScript的运行环境，仅仅提供了基础的功能和API。然而，基于Node.js提供的这些基础功能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了Node.js，可以让前端程序员胜任更多的工作和岗位：</p><ul><li><a href="http://www.expressjs.com.cn/">基于Express框架，可以快速构建Web应用</a></li><li><a href="https://electronjs.org/">基于Electron框架，可以构建跨平台的桌面应用</a></li><li><a href="http://restify.com/">基于restify框架，可以快速构建API接口项目</a></li><li>读写和操作数据库、创建实用的命令行工具辅助前端开发、ect…</li></ul></li><li><p>Node.js好学吗？</p><p> 会JavaScript，就能学会Node.js</p></li><li><p>Node.js怎么学？</p><p> 浏览器中的JavaScript学习路径：<br> JavaScript基础语法 + 浏览器内置API(DOM + BOM) + 第三方库(jQuery、art-template等)<br> Node.js的学习路径：<br> JavaScript基础语法 + Node.js内置API模块(fs、path、http等) + 第三方API模块(express、mysql)</p></li></ol><p>3、Node.js环境的安装</p><p>安装包可以从Node.js的官网首页直接下载，进入到<a href="https://nodejs.org/en/">Node.js的官网首页</a>，点击绿色的按钮，下载所需版本后双击直接安装即可</p><ol><li><p>区分LTS你版本和Current版本的不同</p><p> 1 LTS为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装LTS版本的Node.js<br> 2 Current为新特性尝鲜版，对热衷于尝试新特征的用户来说，推荐安装Current版本的Node.js。但是，Current版本中可能存在隐藏的Bug或安全性漏洞，应此不推荐在企业级项目中使用Current版本的Node.js</p></li><li><p>查看已安装的Node.js的版本号</p><p> 打开终端，在终端输入命令 node -v 后，按下回车键，即可查看已安装的Node.js的版本号</p></li><li><p>什么是终端？</p><p> 终端(英文:Terminal)是专门为开发人员设计的，用与实现人机交互的一种方式</p></li></ol><p>4、在Node.js环境中执行JavaScript代码</p><ul><li>打开终端</li><li>输入node要执行的js文件的路径</li></ul><ol><li><p>终端中的快捷键</p><p> 在Windows的powershell或cmd终端中，我们可以通知如下快捷键，来提高终端的操作效率:</p><pre><code class="hljs"> 1 使用向上键，可以快速定位上一次执行的命令 2 使用tab键，能够快速补全路径 3 使用esc键，能够快速清空当前已输入的命令 4 输入cls命令，可以清空终端</code></pre></li></ol><h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><p>1、什么是fs文件系统模块</p><pre><code class="hljs">fs模块是Node.js官方提供的、用来操作文件的模块。它们提供了一些列的方法和属性，用来满足用户对文件的操作需求例如：    fs.readFile()方法，用来读取指定文件中的内容    fs.writeFile()方法，用来向指定的文件中写入内容    如果要在JavaScript代码中，使用fs模块来操作文件，则需要使用如下的方式先导入它：    const fs=require(&#39;fs&#39;);</code></pre><p>2、读取指定文件中的内容</p><ol><li><p>fs.readFile()的语法格式</p><p> 使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：</p></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File(<span class="hljs-params">path</span>[,<span class="hljs-params">options</span>],<span class="hljs-params">callback</span>)</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">参数解读：    参数1：必选参数，字符串，表示文件的路径。    参数2：可选参数，表示以什么编码格式来读取文件    参数3：必选参数，文件读取完成后，通过回调函数拿到读取结果</code></pre><ol start="2"><li><p>fs.readFile()的示例代码</p><p> 以utf8的编码格式，读取指定文件的内容，并打印err和dataStr的值</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 导入fs模块，来操作文件<br>const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 调用fs.readFile()方法读取文件<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">1</span>：读取文件的存放路径、<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">2</span>：读取文件时候采用的编码格式，一般默认指定utf8<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">3</span>：回调函数，拿到读取失败和成功的结果 err datastr<br>fs.readFile(<span class="hljs-string">&#x27;./nodejs测试.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (err, dataStr) &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span>打印失败的结果<br>    <span class="hljs-regexp">//</span> 如果读取成功，则err的值为null<br>    <span class="hljs-regexp">//</span> 如果读取失败，则err的值为错误对象，datastr的值为underfined<br>    console.log(err);<br>    console.log(<span class="hljs-string">&#x27;---&#x27;</span>);<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2.2</span>打印成功的结果<br>    console.log(dataStr);<br>&#125;) <br><br></code></pre></td></tr></table></figure><ol start="3"><li><p>判断文件是否读取成功</p><p> 可以判断err对象是否为null，从而知晓文件读取的结果</p></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.readFile(<span class="hljs-string">&#x27;./nodejs.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err,dataStr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.message);<br>    &#125;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取成功！&#x27;</span>+dataStr);<br>&#125;)<br></code></pre></td></tr></table></figure><p>3、向指定的文件中写入内容</p><ol><li><p>fs.writeFile()的语法格式</p><p> 使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：</p></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fs.write<span class="hljs-constructor">File(<span class="hljs-params">file</span>,<span class="hljs-params">data</span>[,<span class="hljs-params">options</span>],<span class="hljs-params">callback</span>)</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">参数接读：    参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。    参数2：必选参数，表示要写入的内容    参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8    参数4：必选参数，文件写入完成后的回调函数</code></pre><ol start="2"><li><p>fs.writeFile()的示例代码</p><p> 向指定的文件路径中，写入文件内容：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 导入fs文件系统模块<br>const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 调用fs.writeFile()方法，写入文件的内容<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">1</span>：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">2</span>：必选参数，表示要写入的内容<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">3</span>：可选参数，表示以什么格式写入文件内容，默认值是utf8<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">4</span>：必选参数，文件写入完成后的回调函数<br>fs.writeFile(<span class="hljs-string">&#x27;./nodejs.txt&#x27;</span>, <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-keyword">function</span> (err, dataStr) &#123;<br>    <span class="hljs-regexp">//</span> 如果文件写入成功，则err的值等于null、<br>    <span class="hljs-regexp">//</span> 如果文件写入失败，则err的值等于一个错误对象<br>console.log(err);<br>&#125;) <br></code></pre></td></tr></table></figure><ol start="3"><li><p>判断文件是否写入成功 </p><p> 可以判断err对象是否为null，从而知晓文件写入的结果</p></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.writeFile(<span class="hljs-string">&#x27;./nodejs.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err,dataStr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.message);<br>    &#125;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取成功！&#x27;</span>+dataStr);<br>&#125;)<br></code></pre></td></tr></table></figure><p>4、练习-考试成绩整理</p><pre><code class="hljs">使用fs文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。整理前，成绩.txt文件中的数据格式如下：小红=99 小白=100， 小黄=70 小黑=66 小绿88整理完成之后，希望得到的成绩-ok.txt文件中的数据格式如下：小红=99小白=100小黄=70小黑=66小绿88</code></pre><p>核心实现步骤</p><ol><li>导入需要的fs文件系统模块</li><li>使用fs.readFile()方法，读取素材目录下的成绩.txt文件</li><li>判断文件是否读取失败</li><li>文件读取成功后，处理成绩数据</li><li>将处理完成的成绩数据，调用fs.writeFile()方法，写入到新文件成绩-ok.txt中</li></ol><p>5、fs模块-路径动态拼接的问题</p><pre><code class="hljs">在使用fs模块操作文件时,如果提供的操作路径是以./或../开头的相对路径时,很容易出现路径动态拼接错误的问题原因:代码在运行环境中,会以执行node命令时所处的目录,动态拼接出被操作文件的完整路径解决方案:在使用fs模块操作文件时,直接提供完整的路径,不要提供./或../开头的相对路径,从而防止路径动态拼接的问题__dirname:表示当前文件所处的目录</code></pre><h2 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h2><p>1、什么是path路径模块</p><pre><code class="hljs">path模块是Node.js官方提供的、用来处理路径的模块.它提供了一系列的方法和属性,用来满足用户对路径的处理需求例如:path.join()方法,用来将多个路径片段拼接成一个完整的路径字符串path.basename()方法,用来从路径字符串中,将文件名解析出来如果要在JavaScript代码中,使用path模块来处理路径,则需要使用如下的方式先导入它const path=require(&#39;path&#39;)</code></pre><p>2、路径拼接</p><ol><li><p>path.join()的语法格式</p><p> 使用path.join()方法,可以把多个路径片段拼接为完整的路径字符串,语法格式如下:</p></li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">path.<span class="hljs-keyword">join</span>(<span class="hljs-meta">[</span><span class="hljs-params">...</span>paths<span class="hljs-meta">]</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">参数解读:    ...paths&lt;sting&gt;路径片段的序列    返回值:&lt;string&gt;</code></pre><ol start="2"><li><p>path.join()的代码示例</p><p> 使用path.join()方法,可以把多个路径片段拼接为完整的路径字符串:</p><pre><code class="hljs"> 注意:今后凡是涉及到路径拼接的操作,都要使用path.join()方法进行处理,不要直接使用+进行字符串的拼接</code></pre></li></ol><p>3、获取路径中的文件名</p><ol><li><p>path.basename()的语法格式</p><p> 使用path.basename()方法,可以获取路径中的最后一部分,经常通过这个方法获取路径中的文件名,语法格式如下:</p><pre><code class="hljs"> path.basename(path[,ext])</code></pre><p> 参数解读:</p><pre><code class="hljs"> path&lt;string&gt;必选参数,表示一个路径的字符串 ext&lt;string&gt;可选参数,表示文件扩展名 返回:&lt;string&gt;表示路径中的最后一部分</code></pre></li><li><p>path.basename()的代码示例</p><p> 使用path.basename()方法,可以从一个文件路径中,获取到文件的名称部分</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-regexp">//</span>定义文件的存放路径<br>const fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span>;<br><br><span class="hljs-regexp">//</span>const fullName=path.basename(fpath)<br><span class="hljs-regexp">//</span> console.log(fullName);<span class="hljs-regexp">//</span>输出 index.html<br>const nameWithoutExt = path.basename(fpath, <span class="hljs-string">&#x27;.html&#x27;</span>);<br>console.log(nameWithoutExt);<span class="hljs-regexp">//</span>输出index<br></code></pre></td></tr></table></figure><p>4、获取路径中的文件扩展名</p><ol><li><p>path.extname()的语法格式</p><p> 使用path.extname()方法,可以获取路径中的扩展名部分,语法格式如下:</p><pre><code class="hljs"> path.extname(path)</code></pre><p> 参数解读:</p><pre><code class="hljs"> path&lt;string&gt;必选参数,表示一个路径的字符串 返回:&lt;string&gt;返回得到的扩展名字符串</code></pre></li><li><p>path.extname()的代码示例</p><p> 使用path.extname()方法,可以获取路径中的扩展名部分:</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-comment">//这里是文件的存放路径</span><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;a/b/c/index.html&#x27;</span>;<span class="hljs-comment">//路径字符串</span><br><span class="hljs-keyword">const</span> fext = path.<span class="hljs-title function_">extname</span>(fpath);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fext);<span class="hljs-comment">//输出.html</span><br></code></pre></td></tr></table></figure><p>5、综合案例-时钟案例</p><ol><li><p>案例要实现的功能</p><p> 将素材目录下的index.html页面,拆分成三个文件,分别是:</p><pre><code class="hljs"> index.css index.js index.html</code></pre><p> 并且将拆分出来的3个文件,寄放到clock目录中</p></li><li><p>案例的实现步骤</p><pre><code class="hljs"> 1 创建两个正则表达式,分别用来匹配&amp;lt;style&gt;和&amp;lt;script&gt;标签 2 使用fs模块,读取需要被处理的HTML文件 3 自定义resolveCSS方法,来写入index.css样式文件 4 自定义resolveJS方法,来写入index.js脚本文件 5 自定义resolveHTML方法,来写入index.html文件</code></pre></li><li><p>步骤1-导入需要的模块并创建正则表达式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>导入fs模块<br>const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-regexp">//</span>导入path模块<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const &#123; Script &#125; = require(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 定义正则表达式分别匹配&lt;style&gt;&lt;<span class="hljs-regexp">/style&gt;和&lt;Script&gt;&lt;/</span>Script&gt;标签<br><span class="hljs-regexp">//</span> /s:代表匹配空字符<br><span class="hljs-regexp">//</span> \S:代表匹配非空字符<br><span class="hljs-regexp">//</span> [\s\S]:匹配任意字符<br><span class="hljs-regexp">//</span> *:多次<br>const regStyle = <span class="hljs-regexp">/&lt;style&gt;[\s\S]*&lt;\/style&gt;/</span>;<br>const regScript =<span class="hljs-regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span>;<br></code></pre></td></tr></table></figure></li><li><p>步骤2-使用fs模块读书需要被处理的html文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//2.1读取需要被处理的HTML文件</span><br>fs.read<span class="hljs-constructor">File(<span class="hljs-params">path</span>.<span class="hljs-params">join</span>(<span class="hljs-params">__dirname</span>, &#x27;.<span class="hljs-operator">/</span><span class="hljs-params">index</span>.<span class="hljs-params">html</span>&#x27;)</span>, &#x27;utf8&#x27;,<span class="hljs-function"> (<span class="hljs-params">err</span>, <span class="hljs-params">dataStr</span>)=&gt;</span> &#123;<br><span class="hljs-comment">//  2.2读取HTML文件失败</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>    return console.log(&#x27;文件读取失败&#x27;+err.message);<br>    &#125;    <br>    <span class="hljs-comment">// 2.3 读取HTML文件成功后,调用对应的方法,拆解出css...js和html文件</span><br>    resolve<span class="hljs-constructor">CSS(<span class="hljs-params">dataStr</span>)</span><br>    resolve<span class="hljs-constructor">JS(<span class="hljs-params">dataStr</span>)</span><br>    resolve<span class="hljs-constructor">HTML(<span class="hljs-params">dataStr</span>)</span><br>    <br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>步骤3-自定义resolveCSS方法</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">    <span class="hljs-comment">// 3.1处理CSS样式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveCSS</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>    <span class="hljs-comment">//3.2使用正则表达式读取页面中的&lt;style&gt;&lt;/style&gt;标签</span><br>    const r1 = regStyle.exec(htmlStr);<br>    <span class="hljs-comment">// 3.3 将提取出来的样式字符串,做进一步的处理</span><br>    const newCSS = r1[<span class="hljs-number">0</span>].<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;style&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;/style&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br><br>    <span class="hljs-comment">// 3.4将提取出来的css样式,写入到index.css文件中</span><br>    fs.writeFile(path.join(__dirname, <span class="hljs-string">&#x27;./index.css&#x27;</span>), newCSS, err =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式失败&#x27;</span> + err.message);<br>        &#125;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式成功!&#x27;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>步骤4-自定义resolveJS方法</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 3.1处理js代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveJS</span>(<span class="hljs-params">JSStr</span>) &#123;<br>    <span class="hljs-comment">//3.2使用正则表达式读取页面中的&lt;style&gt;&lt;/style&gt;标签</span><br>    const r1 = regScript.exec(JSStr);<br>    <span class="hljs-comment">// 3.3 将提取出来的样式字符串,做进一步的处理</span><br>    const newJS = r1[<span class="hljs-number">0</span>].<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;script&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;/script&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br><br>    <span class="hljs-comment">// 3.4将提取出来的css样式,写入到index.css文件中</span><br>    fs.writeFile(path.join(__dirname, <span class="hljs-string">&#x27;./index.js&#x27;</span>), newJS, err =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式失败&#x27;</span> + err.message);<br>        &#125;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式成功!&#x27;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>步骤5-自定义resolveHTML方法</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 5. 处理html文件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveHTML</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>    <span class="hljs-comment">// 5.1使用字符串的replace方法, 把内嵌的 &lt; style &gt; 和 &lt; script &gt; 标签, 替换为外联的 &lt; link &gt; 划和 &lt; script &gt; 标签</span><br>    const newHTML = htmlStr<br>        .<span class="hljs-built_in">replace</span>(regStyle, <span class="hljs-string">&#x27;&lt;lick rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;</span>)<br>        .<span class="hljs-built_in">replace</span>(regScript, <span class="hljs-string">&#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;</span>)<br>    <span class="hljs-comment">// 5.2将替换完成之后的html代码,写入到index.html文件中</span><br>    fs.writeFile(path.join(__dirname, <span class="hljs-string">&#x27;./index.html&#x27;</span>), newHTML, err =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入失败&#x27;</span>+err.message);<br>        &#125;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>案例的两个注意点</p><p> 1 fs.writeFile()方法只能用来创建文件，不能用来创建路径<br> 2 重复调用fs.writeFile()写入同一个文件，新写入的内容会覆盖之前的旧内容</p></li></ol><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>1、什么是http模块</p><pre><code class="hljs">回顾：什么是客户端、什么是服务器？在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器；http模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer()方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。注意：如果要希望使用http模块创建Web服务器，则需要先导入它：            const http=require(&#39;http&#39;);</code></pre><p>2、进一步理解http模块的作用</p><pre><code class="hljs">服务器和普通的区别在于，服务器上安装了Web服务器软件，例如：IIS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器在Node.js中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能手写一个服务器软件，从而对外提供web服务</code></pre><p>3、服务器相关的概念</p><ol><li><p>IP地址</p><p> IP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。如果把‘个人电脑’比作‘一台电脑’，那么‘IP地址’就相当于‘电话号码’，只有在知道对方IP的前提下，才能与对应的电脑之间进行数据通信</p><p> IP地址的格式：通常用‘点分十进制’表示成(a,b,c,d)的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如：用点分十进制表示IP地址(192.168.1.1)</p><p> 注意：</p><pre><code class="hljs"> 1 互联网中每台Web服务器，都有自己的IP地址，例如：大家可以在Windows的终端中运行ping www.baidu.com命令，即可查看百度服务器的IP地址  2 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当做一台服务器进行访问了 </code></pre></li><li><p>域名和域名服务器</p><p> 尽管IP地址能够唯一地址标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名(Domain Name)地址</p><p> IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS,Domain name server)的电脑中，使用者只需要通过好记得域名访问对应得服务器即可，对应得转换工作由域名服务器实现，因此，域名服务器就是提供IP地址和域名之间得转换服务的服务器</p><p> 注意：</p><pre><code class="hljs"> 1 单纯使用IP地址，互联网中的电脑也能正常工作，但是有了域名后的加持，能让互联网的世界变得更加方便 2 在开发测试期间，127.0.0.1对应域名是localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别</code></pre></li><li><p>端口号</p><p> 计算机中的端口号，就好像是现实生活中的门牌号，通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中</p><p> 同样的道理，在一台电脑中，可以运行成百上千个web服务器</p><p> 注意：</p><pre><code class="hljs"> 1 每个端口号不能同时被多个web服务器占用 2 在实际应用中，URL中的80端口可以被省略</code></pre></li></ol><p>4、创建最基本的web服务器</p><ol><li><p>创建web服务器的基本步骤</p><ol><li>导入http模块</li><li>创建web服务器实例</li><li>为服务器实例绑定request事件，监听客户端的请求</li><li>启动服务器</li></ol></li><li><p>步骤1 - 导入http模块</p><p> 如果希望在自己的电脑上创建一个web服务器，从而对外提供web服务，则需要导入模块：</p></li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const http</span>=require(<span class="hljs-string">&#x27;http&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><p>步骤2 - 创建web服务器实例</p><p> 调用http.createServer()方法，即可快速创建一个web服务器实例：</p></li></ol><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-keyword">server</span>=http.createServer()<br></code></pre></td></tr></table></figure><ol start="2"><li><p>步骤3 - 为服务器实例绑定request事件</p><p> 为服务器实例绑定request事件，即可监听客户端发送过来的网络请求：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>使用服务器实例的 .<span class="hljs-literal">on</span>()方法，为服务器绑定一个request事件<br>server.<span class="hljs-literal">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>    <span class="hljs-regexp">//</span>只要有客户端来请求我们自己的服务器，就会触发request事件，从而调用这个事件处理函数<br>    console.log(<span class="hljs-string">&#x27;Someone visit our web server.&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>步骤4 - 启动服务器</p><p> 调用服务器实例的.listen()方法，即可启动当前的web服务器实例;</p></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//调用<span class="hljs-keyword">server</span>.<span class="hljs-keyword">listen</span>(端口号，cb回调)方法，即可启动web服务器<br><span class="hljs-keyword">server</span>.<span class="hljs-keyword">listen</span>(<span class="hljs-number">80</span>,()=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;http server running at http://127.0.0.1&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>req请求对象</p><p> 只要服务器接收到了客户端的请求,就会调用server.on()为服务器绑定的request事件处理函数.如果想在事件处理函数中,访问与客户端相关的数据或属性,可以使用如下的方式;</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,(req)=&gt;&#123;<br>    <span class="hljs-comment">//req是请求对象,它包含了与客户端相关的数据和属性,例如:</span><br>    <span class="hljs-comment">//req.url是客户端请求的URL地址</span><br>    <span class="hljs-comment">//req.method是客户端的method请求类型</span><br>    <span class="hljs-keyword">const</span> str=<span class="hljs-string">&#x27;Your request url is <span class="hljs-subst">$&#123;req.url&#125;</span>,and request method is <span class="hljs-subst">$&#123;req.method&#125;</span>&#x27;</span><br>    console.log(str);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li><p>res响应对象</p><p> 在服务器的request事件处理函数中,如果想访问与服务器相关的数据或属性,可以使用如下的方式:</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//res是响应对象,它包含了与服务器相关的数据和属性,例如:</span><br>    <span class="hljs-comment">//要发送到客户端的字符串</span><br>    <span class="hljs-keyword">const</span> str=<span class="hljs-string">&#x27;Your request url is <span class="hljs-subst">$&#123;req.url&#125;</span>,and request method is <span class="hljs-subst">$&#123;req.method&#125;</span>&#x27;</span>;<br>    <span class="hljs-comment">//res.end()方法的作用;</span><br>    <span class="hljs-comment">//向客户端发送指定的内容,并结束这次请求的处理过程</span><br>    res.end(str)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>解决中文乱码问题</p><p> 当调用res.end()方法,向客户端发送中文内容的时候,会出现乱码问题,此时,需要手动设置内容的编码格式:</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//发送的内容包含中文</span><br>    <span class="hljs-keyword">const</span> str=<span class="hljs-string">&#x27;您请求的url地址是<span class="hljs-subst">$&#123;req.url&#125;</span>,请求的method类型是<span class="hljs-subst">$&#123;req.method&#125;</span>&#x27;</span><br>    <span class="hljs-comment">//为了防止中文显示乱码的问题,需要设置响应头Content - Type 的值为text/html;charset=utf-8</span><br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>);<br>    <span class="hljs-comment">//把包含中文的内容,响应给客户端</span><br>    res.end(str);<br>&#125;)<br></code></pre></td></tr></table></figure><p>5、根据不同的url响应不同的html内容</p><ol><li><p>核心实现步骤</p><ol><li>获取请求的url地址</li><li>设置默认的响应内容为404 Not found</li><li>判断用户请求的是否为&#x2F;或index.html首页</li><li>判断用户请求的是否为&#x2F;about.html关于页面</li><li>设置Content-Type响应头,防止中文乱码</li><li>使用res.end()把内容响应给客户端</li></ol></li><li><p>动态响应内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">server<span class="hljs-selector-class">.on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-built_in">function</span>(req,res)&#123;<br>    const url=req<span class="hljs-selector-class">.url</span>               <span class="hljs-comment">//1. 获取请求的url地址</span><br>let <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span>;<span class="hljs-comment">//2. 设置默认的响应内容为404 Not found</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(url===<span class="hljs-string">&#x27;/&#x27;</span>||url===<span class="hljs-string">&#x27;/index.html&#x27;</span>)</span></span>&#123;<br>    <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span>;            <span class="hljs-comment">//3. 判断用户请求的是否为/或index.html首页</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(url===<span class="hljs-string">&#x27;/about.html&#x27;</span>)&#123;<br>    <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span>;        <span class="hljs-comment">// 4. 判断用户请求的是否为/about.html关于页面</span><br>&#125;<br>   <br>res<span class="hljs-selector-class">.setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>)<span class="hljs-comment">//5. 设置Content-Type响应头,防止中文乱码</span><br>res<span class="hljs-selector-class">.end</span>(<span class="hljs-attribute">content</span>);<span class="hljs-comment">//6. 使用res.end()把内容响应给客户端</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>6、案例 - 实现clock时钟的web服务器</p></li><li><p>核心思路</p><p> 把文件的实际存放路径，作为每个资源的请求url地址</p></li><li><p>实现步骤</p><ol><li>导入需要的模块</li><li>创建基本的web服务器</li><li>将资源的请求url地址映射为文件的存放路径</li><li>读取文件内容并响应给客户端</li><li>优化资源的请求路径</li></ol></li><li><p>步骤1 - 导入需要的模块(具体看05.clock时钟web服务器.js文件)</p></li><li><p>步骤2 - 创建基本的web服务器(具体看05.clock时钟web服务器.js文件)</p></li><li><p>步骤3 - 将资源的请求url地址映射为文件的存放路径(具体看05.clock时钟web服务器.js文件)</p></li><li><p>步骤四 - 读取文件的内容并响应给客户端(具体看05.clock时钟web服务器.js文件)</p></li><li><p>步骤5 - 优化资源的请求路径</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>将<span class="hljs-number">3.2</span>的实现方式，改为如下代码<br><span class="hljs-regexp">//</span><span class="hljs-number">5.1</span>预定义空白的文件存放路径<br>let fpath=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">if</span>(url===<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-number">5.2</span>如果请求的路径是否为/,则手动指定文件的存放路径<br>    fpath=path.join(__dirname,<span class="hljs-string">&#x27;./clock/indexmhtml&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-number">5.3</span>如果请求的路径不为/ ，则动态拼接文件的存放路径<br>    fpath=path.join(__dirname,<span class="hljs-string">&#x27;./clock&#x27;</span>,url);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="模块化的基本概念"><a href="#模块化的基本概念" class="headerlink" title="模块化的基本概念"></a>模块化的基本概念</h2><p>1、什么是模块化</p><pre><code class="hljs">模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块时可组合，分解和更换的单元</code></pre><ol><li><p>现实生活中的模块化</p><p> 霸王游戏机</p></li><li><p>编程领域中的模块化</p><p> 编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块</p><p> 把代码进行模块化拆分的好处：</p><pre><code class="hljs"> 1. 提高了代码的复用性 2. 提高了代码的可维护性 3. 可以实现按需加载</code></pre></li></ol><p>2、模块化规范</p><pre><code class="hljs">模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。例如：    使用什么样的语法格式来引用模块    在模块中使用什么样的语法格式向外暴露成员模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。</code></pre><h2 id="Node-js中的模块化"><a href="#Node-js中的模块化" class="headerlink" title="Node.js中的模块化"></a>Node.js中的模块化</h2><p>1、Node.js中模块化的分类</p><pre><code class="hljs">Node.js中根据模块来源不同，将模块分为了3大类，分别是：内置模块(内置模块是由Node.js官方提供的，例如fs、path、http等)自定义模块(用户创建的每个js文件，都是自定义模块)第三方模块(由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载)</code></pre><p>2、加载模块</p><pre><code class="hljs">使用强大的require()方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：    const custom=require(&#39;./custom.js&#39;);注意：使用require()方法加载其它模块时，会执行被加载模块中的代码</code></pre><p>3、Node.js中的模块作用域</p><ol><li><p>什么是模块作用域</p><p> 和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</p></li><li><p>模块作用域的好处</p><p> 防止全局变量污染的问题</p></li></ol><p>4、向外共享模块作用域中的成员</p><ol><li><p>module对象</p><p> 在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息，打印如下：</p></li><li><p>module.exports对象</p><p> 在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。</p><p> 外界用require()方法导入自定义模块时，得到的就是module.exports所指向的对象</p></li><li><p>共享成员时的注意点</p><p> 使用reuire()方法导入模块时，导入的结果，永远以module.exports指向的对象为准</p></li><li><p>exports对象</p><p> 由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node提供了exports对象。默认情况下，exports和module.exports指向同一个对象，最终共享的结果，还是以module.exports指向的对象为准</p></li><li><p>exports和module.exporets的使用误区</p><p> 时刻谨记，require()模块时，得到的永远是module.exports指向的对象</p><p> 注意：为了防止混乱，建议大家不要在同一个模块中同时使用exports和module.exports</p></li></ol><p>5、Node.js中的模块化规范</p><pre><code class="hljs">Node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖CommonJS规定：    1.每个模块内部，module变量代表当前模块。    2. module变量是一个对象，它的exports属性(即module.exports)是对外的接口    3. 加载某个模块，其实是加载该模块的module.exports属性，require()方法用于加载模块 </code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1>sdasdas</h1>]]></content>
    
  </entry>
  
  
  
</search>
