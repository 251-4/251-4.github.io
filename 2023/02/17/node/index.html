

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blog.png">
  <link rel="icon" href="/img/blog.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="人生几何">
  <meta name="keywords" content="">
  
    <meta name="description" content="node介绍：node是一个JS运行环境，一个用chrome浏览器V8引擎来跑JS代码的环境。">
<meta property="og:type" content="article">
<meta property="og:title" content="Node">
<meta property="og:url" content="https://251-4.github.io/2023/02/17/node/index.html">
<meta property="og:site_name" content="251-4">
<meta property="og:description" content="node介绍：node是一个JS运行环境，一个用chrome浏览器V8引擎来跑JS代码的环境。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hbfile.huaban.com/img/home/banner/a3e4f1047d95d7b87d0faa2bbd31f0ea60b4e7bf17e888">
<meta property="article:published_time" content="2023-02-17T03:30:21.938Z">
<meta property="article:modified_time" content="2023-03-10T01:26:29.386Z">
<meta property="article:author" content="人生几何">
<meta property="article:tag" content="node">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hbfile.huaban.com/img/home/banner/a3e4f1047d95d7b87d0faa2bbd31f0ea60b4e7bf17e888">
  
  
  
  <title>Node - 251-4</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"251-4.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":3},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>251-4</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/plan/">
                <i class="iconfont icon-plan"></i>
                <span>计划</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Node"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        人生几何
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-17 11:30" pubdate>
          2023年2月17日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Node</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="node介绍："><a href="#node介绍：" class="headerlink" title="node介绍："></a>node介绍：</h1><p>node是一个JS运行环境，一个用chrome浏览器V8引擎来跑JS代码的环境。</p>
<!-- 文章页卡片展示文本 -->
<span id="more"></span>
<h2 id="初识Node-js"><a href="#初识Node-js" class="headerlink" title="初识Node.js"></a>初识Node.js</h2><p>1、回顾与思考</p>
<ol>
<li><p>浏览器中的JavaScript的组成部分？</p>
<p> JS核心语法          WebAPI<br> 变量、数据类型      DOM操作<br> 循环、分支、判断    BOM操作<br> 函数、作用域、this  基于XMLHttpRequest的Ajax操作<br> etc…              etc…</p>
</li>
<li><p>思考：为什么JavaScript可以在浏览器中被执行？</p>
<p> 因为有JavaScript解析引擎(不同浏览器的解析引擎不同，从而出现差异，其中谷歌最好)</p>
</li>
<li><p>思考：为什么JavaScript可以操作DOM和BOM？</p>
<p> 因为每个浏览器都内置了DOM、BOM这样的APL函数，因此，浏览器中的JavaScript才可以调用它们</p>
</li>
<li><p>思考：浏览器中的JavaScript运行环境(指正常运行所必需的必要环境)</p>
<p> 因为：</p>
<p> 1 V8引擎负责解析和执行JavaScript代码</p>
<p> 2 内置API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用</p>
</li>
<li><p>思考：JavaScript能否做后端开发？(常见的Java、python、PHP等后端语言)</p>
<p> 可以，但是需要node.js来进行后端开发的运行环境</p>
</li>
</ol>
<p>2、 node.js简介</p>
<ol>
<li><p>什么是Node.js？</p>
<p> Node.js是一个基于Chrome V8引擎的JavaScript运行环境<br> node.js的官方地址：<a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
</li>
<li><p>Node.js中的JavaScript运行环境</p>
<p> 1 浏览器是JavaScript的前端运行环境<br> 2 Node.js是JavaScript的后端运行环境<br> 3 Node.js中无法调用DOM和BOM等浏览器内置API</p>
</li>
<li><p>Node.js可以做什么？</p>
<p> Node.js作为一个JavaScript的运行环境，仅仅提供了基础的功能和API。然而，基于Node.js提供的这些基础功能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了Node.js，可以让前端程序员胜任更多的工作和岗位：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.expressjs.com.cn/">基于Express框架，可以快速构建Web应用</a></li>
<li><a target="_blank" rel="noopener" href="https://electronjs.org/">基于Electron框架，可以构建跨平台的桌面应用</a></li>
<li><a target="_blank" rel="noopener" href="http://restify.com/">基于restify框架，可以快速构建API接口项目</a></li>
<li>读写和操作数据库、创建实用的命令行工具辅助前端开发、ect…</li>
</ul>
</li>
<li><p>Node.js好学吗？</p>
<p> 会JavaScript，就能学会Node.js</p>
</li>
<li><p>Node.js怎么学？</p>
<p> 浏览器中的JavaScript学习路径：<br> JavaScript基础语法 + 浏览器内置API(DOM + BOM) + 第三方库(jQuery、art-template等)<br> Node.js的学习路径：<br> JavaScript基础语法 + Node.js内置API模块(fs、path、http等) + 第三方API模块(express、mysql)</p>
</li>
</ol>
<p>3、Node.js环境的安装</p>
<p>安装包可以从Node.js的官网首页直接下载，进入到<a target="_blank" rel="noopener" href="https://nodejs.org/en/">Node.js的官网首页</a>，点击绿色的按钮，下载所需版本后双击直接安装即可</p>
<ol>
<li><p>区分LTS你版本和Current版本的不同</p>
<p> 1 LTS为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装LTS版本的Node.js<br> 2 Current为新特性尝鲜版，对热衷于尝试新特征的用户来说，推荐安装Current版本的Node.js。但是，Current版本中可能存在隐藏的Bug或安全性漏洞，应此不推荐在企业级项目中使用Current版本的Node.js</p>
</li>
<li><p>查看已安装的Node.js的版本号</p>
<p> 打开终端，在终端输入命令 node -v 后，按下回车键，即可查看已安装的Node.js的版本号</p>
</li>
<li><p>什么是终端？</p>
<p> 终端(英文:Terminal)是专门为开发人员设计的，用与实现人机交互的一种方式</p>
</li>
</ol>
<p>4、在Node.js环境中执行JavaScript代码</p>
<ul>
<li>打开终端</li>
<li>输入node要执行的js文件的路径</li>
</ul>
<ol>
<li><p>终端中的快捷键</p>
<p> 在Windows的powershell或cmd终端中，我们可以通知如下快捷键，来提高终端的操作效率:</p>
<pre><code class="hljs"> 1 使用向上键，可以快速定位上一次执行的命令
 2 使用tab键，能够快速补全路径
 3 使用esc键，能够快速清空当前已输入的命令
 4 输入cls命令，可以清空终端
</code></pre>
</li>
</ol>
<h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><p>1、什么是fs文件系统模块</p>
<pre><code class="hljs">fs模块是Node.js官方提供的、用来操作文件的模块。它们提供了一些列的方法和属性，用来满足用户对文件的操作需求

例如：
    fs.readFile()方法，用来读取指定文件中的内容
    fs.writeFile()方法，用来向指定的文件中写入内容
    如果要在JavaScript代码中，使用fs模块来操作文件，则需要使用如下的方式先导入它：
    const fs=require(&#39;fs&#39;);
</code></pre>
<p>2、读取指定文件中的内容</p>
<ol>
<li><p>fs.readFile()的语法格式</p>
<p> 使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：</p>
</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File(<span class="hljs-params">path</span>[,<span class="hljs-params">options</span>],<span class="hljs-params">callback</span>)</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs">参数解读：

    参数1：必选参数，字符串，表示文件的路径。
    参数2：可选参数，表示以什么编码格式来读取文件
    参数3：必选参数，文件读取完成后，通过回调函数拿到读取结果
</code></pre>
<ol start="2">
<li><p>fs.readFile()的示例代码</p>
<p> 以utf8的编码格式，读取指定文件的内容，并打印err和dataStr的值</p>
</li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 导入fs模块，来操作文件<br>const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 调用fs.readFile()方法读取文件<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">1</span>：读取文件的存放路径、<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">2</span>：读取文件时候采用的编码格式，一般默认指定utf8<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">3</span>：回调函数，拿到读取失败和成功的结果 err datastr<br>fs.readFile(<span class="hljs-string">&#x27;./nodejs测试.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (err, dataStr) &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span>打印失败的结果<br>    <span class="hljs-regexp">//</span> 如果读取成功，则err的值为null<br>    <span class="hljs-regexp">//</span> 如果读取失败，则err的值为错误对象，datastr的值为underfined<br>    console.log(err);<br>    console.log(<span class="hljs-string">&#x27;---&#x27;</span>);<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2.2</span>打印成功的结果<br>    console.log(dataStr);<br>&#125;) <br><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><p>判断文件是否读取成功</p>
<p> 可以判断err对象是否为null，从而知晓文件读取的结果</p>
</li>
</ol>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.readFile(<span class="hljs-string">&#x27;./nodejs.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err,dataStr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.message);<br>    &#125;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取成功！&#x27;</span>+dataStr);<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>3、向指定的文件中写入内容</p>
<ol>
<li><p>fs.writeFile()的语法格式</p>
<p> 使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：</p>
</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fs.write<span class="hljs-constructor">File(<span class="hljs-params">file</span>,<span class="hljs-params">data</span>[,<span class="hljs-params">options</span>],<span class="hljs-params">callback</span>)</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs">参数接读：

    参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。
    参数2：必选参数，表示要写入的内容
    参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8
    参数4：必选参数，文件写入完成后的回调函数
</code></pre>
<ol start="2">
<li><p>fs.writeFile()的示例代码</p>
<p> 向指定的文件路径中，写入文件内容：</p>
</li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 导入fs文件系统模块<br>const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 调用fs.writeFile()方法，写入文件的内容<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">1</span>：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">2</span>：必选参数，表示要写入的内容<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">3</span>：可选参数，表示以什么格式写入文件内容，默认值是utf8<br><span class="hljs-regexp">//</span> 参数<span class="hljs-number">4</span>：必选参数，文件写入完成后的回调函数<br>fs.writeFile(<span class="hljs-string">&#x27;./nodejs.txt&#x27;</span>, <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-keyword">function</span> (err, dataStr) &#123;<br>    <span class="hljs-regexp">//</span> 如果文件写入成功，则err的值等于null、<br>    <span class="hljs-regexp">//</span> 如果文件写入失败，则err的值等于一个错误对象<br>console.log(err);<br>&#125;) <br></code></pre></td></tr></table></figure>
<ol start="3">
<li><p>判断文件是否写入成功 </p>
<p> 可以判断err对象是否为null，从而知晓文件写入的结果</p>
</li>
</ol>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.writeFile(<span class="hljs-string">&#x27;./nodejs.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err,dataStr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.message);<br>    &#125;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;读取成功！&#x27;</span>+dataStr);<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>4、练习-考试成绩整理</p>
<pre><code class="hljs">使用fs文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。

整理前，成绩.txt文件中的数据格式如下：
小红=99 小白=100， 小黄=70 小黑=66 小绿88
整理完成之后，希望得到的成绩-ok.txt文件中的数据格式如下：
小红=99
小白=100
小黄=70
小黑=66
小绿88
</code></pre>
<p>核心实现步骤</p>
<ol>
<li>导入需要的fs文件系统模块</li>
<li>使用fs.readFile()方法，读取素材目录下的成绩.txt文件</li>
<li>判断文件是否读取失败</li>
<li>文件读取成功后，处理成绩数据</li>
<li>将处理完成的成绩数据，调用fs.writeFile()方法，写入到新文件成绩-ok.txt中</li>
</ol>
<p>5、fs模块-路径动态拼接的问题</p>
<pre><code class="hljs">在使用fs模块操作文件时,如果提供的操作路径是以./或../开头的相对路径时,很容易出现路径动态拼接错误的问题
原因:代码在运行环境中,会以执行node命令时所处的目录,动态拼接出被操作文件的完整路径

解决方案:在使用fs模块操作文件时,直接提供完整的路径,不要提供./或../开头的相对路径,从而防止路径动态拼接的问题

__dirname:表示当前文件所处的目录
</code></pre>
<h2 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h2><p>1、什么是path路径模块</p>
<pre><code class="hljs">path模块是Node.js官方提供的、用来处理路径的模块.它提供了一系列的方法和属性,用来满足用户对路径的处理需求

例如:
path.join()方法,用来将多个路径片段拼接成一个完整的路径字符串
path.basename()方法,用来从路径字符串中,将文件名解析出来

如果要在JavaScript代码中,使用path模块来处理路径,则需要使用如下的方式先导入它
const path=require(&#39;path&#39;)
</code></pre>
<p>2、路径拼接</p>
<ol>
<li><p>path.join()的语法格式</p>
<p> 使用path.join()方法,可以把多个路径片段拼接为完整的路径字符串,语法格式如下:</p>
</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">path.<span class="hljs-keyword">join</span>(<span class="hljs-meta">[</span><span class="hljs-params">...</span>paths<span class="hljs-meta">]</span>)<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">参数解读:

    ...paths&lt;sting&gt;路径片段的序列
    返回值:&lt;string&gt;
</code></pre>
<ol start="2">
<li><p>path.join()的代码示例</p>
<p> 使用path.join()方法,可以把多个路径片段拼接为完整的路径字符串:</p>
<pre><code class="hljs"> 注意:今后凡是涉及到路径拼接的操作,都要使用path.join()方法进行处理,不要直接使用+进行字符串的拼接
</code></pre>
</li>
</ol>
<p>3、获取路径中的文件名</p>
<ol>
<li><p>path.basename()的语法格式</p>
<p> 使用path.basename()方法,可以获取路径中的最后一部分,经常通过这个方法获取路径中的文件名,语法格式如下:</p>
<pre><code class="hljs"> path.basename(path[,ext])
</code></pre>
<p> 参数解读:</p>
<pre><code class="hljs"> path&lt;string&gt;必选参数,表示一个路径的字符串
 ext&lt;string&gt;可选参数,表示文件扩展名
 返回:&lt;string&gt;表示路径中的最后一部分
</code></pre>
</li>
<li><p>path.basename()的代码示例</p>
<p> 使用path.basename()方法,可以从一个文件路径中,获取到文件的名称部分</p>
</li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-regexp">//</span>定义文件的存放路径<br>const fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span>;<br><br><span class="hljs-regexp">//</span>const fullName=path.basename(fpath)<br><span class="hljs-regexp">//</span> console.log(fullName);<span class="hljs-regexp">//</span>输出 index.html<br>const nameWithoutExt = path.basename(fpath, <span class="hljs-string">&#x27;.html&#x27;</span>);<br>console.log(nameWithoutExt);<span class="hljs-regexp">//</span>输出index<br></code></pre></td></tr></table></figure>
<p>4、获取路径中的文件扩展名</p>
<ol>
<li><p>path.extname()的语法格式</p>
<p> 使用path.extname()方法,可以获取路径中的扩展名部分,语法格式如下:</p>
<pre><code class="hljs"> path.extname(path)
</code></pre>
<p> 参数解读:</p>
<pre><code class="hljs"> path&lt;string&gt;必选参数,表示一个路径的字符串
 返回:&lt;string&gt;返回得到的扩展名字符串
</code></pre>
</li>
<li><p>path.extname()的代码示例</p>
<p> 使用path.extname()方法,可以获取路径中的扩展名部分:</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-comment">//这里是文件的存放路径</span><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;a/b/c/index.html&#x27;</span>;<span class="hljs-comment">//路径字符串</span><br><span class="hljs-keyword">const</span> fext = path.<span class="hljs-title function_">extname</span>(fpath);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fext);<span class="hljs-comment">//输出.html</span><br></code></pre></td></tr></table></figure>
<p>5、综合案例-时钟案例</p>
<ol>
<li><p>案例要实现的功能</p>
<p> 将素材目录下的index.html页面,拆分成三个文件,分别是:</p>
<pre><code class="hljs"> index.css
 index.js
 index.html
</code></pre>
<p> 并且将拆分出来的3个文件,寄放到clock目录中</p>
</li>
<li><p>案例的实现步骤</p>
<pre><code class="hljs"> 1 创建两个正则表达式,分别用来匹配&amp;lt;style&gt;和&amp;lt;script&gt;标签
 2 使用fs模块,读取需要被处理的HTML文件
 3 自定义resolveCSS方法,来写入index.css样式文件
 4 自定义resolveJS方法,来写入index.js脚本文件
 5 自定义resolveHTML方法,来写入index.html文件
</code></pre>
</li>
<li><p>步骤1-导入需要的模块并创建正则表达式</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>导入fs模块<br>const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-regexp">//</span>导入path模块<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const &#123; Script &#125; = require(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 定义正则表达式分别匹配&lt;style&gt;&lt;<span class="hljs-regexp">/style&gt;和&lt;Script&gt;&lt;/</span>Script&gt;标签<br><span class="hljs-regexp">//</span> /s:代表匹配空字符<br><span class="hljs-regexp">//</span> \S:代表匹配非空字符<br><span class="hljs-regexp">//</span> [\s\S]:匹配任意字符<br><span class="hljs-regexp">//</span> *:多次<br>const regStyle = <span class="hljs-regexp">/&lt;style&gt;[\s\S]*&lt;\/style&gt;/</span>;<br>const regScript =<span class="hljs-regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>步骤2-使用fs模块读书需要被处理的html文件</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//2.1读取需要被处理的HTML文件</span><br>fs.read<span class="hljs-constructor">File(<span class="hljs-params">path</span>.<span class="hljs-params">join</span>(<span class="hljs-params">__dirname</span>, &#x27;.<span class="hljs-operator">/</span><span class="hljs-params">index</span>.<span class="hljs-params">html</span>&#x27;)</span>, &#x27;utf8&#x27;,<span class="hljs-function"> (<span class="hljs-params">err</span>, <span class="hljs-params">dataStr</span>)=&gt;</span> &#123;<br><span class="hljs-comment">//  2.2读取HTML文件失败</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>    return console.log(&#x27;文件读取失败&#x27;+err.message);<br>    &#125;    <br>    <span class="hljs-comment">// 2.3 读取HTML文件成功后,调用对应的方法,拆解出css...js和html文件</span><br>    resolve<span class="hljs-constructor">CSS(<span class="hljs-params">dataStr</span>)</span><br>    resolve<span class="hljs-constructor">JS(<span class="hljs-params">dataStr</span>)</span><br>    resolve<span class="hljs-constructor">HTML(<span class="hljs-params">dataStr</span>)</span><br>    <br>&#125;)<br></code></pre></td></tr></table></figure></li>
<li><p>步骤3-自定义resolveCSS方法</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">    <span class="hljs-comment">// 3.1处理CSS样式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveCSS</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>    <span class="hljs-comment">//3.2使用正则表达式读取页面中的&lt;style&gt;&lt;/style&gt;标签</span><br>    const r1 = regStyle.exec(htmlStr);<br>    <span class="hljs-comment">// 3.3 将提取出来的样式字符串,做进一步的处理</span><br>    const newCSS = r1[<span class="hljs-number">0</span>].<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;style&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;/style&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br><br>    <span class="hljs-comment">// 3.4将提取出来的css样式,写入到index.css文件中</span><br>    fs.writeFile(path.join(__dirname, <span class="hljs-string">&#x27;./index.css&#x27;</span>), newCSS, err =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式失败&#x27;</span> + err.message);<br>        &#125;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式成功!&#x27;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>步骤4-自定义resolveJS方法</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 3.1处理js代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveJS</span>(<span class="hljs-params">JSStr</span>) &#123;<br>    <span class="hljs-comment">//3.2使用正则表达式读取页面中的&lt;style&gt;&lt;/style&gt;标签</span><br>    const r1 = regScript.exec(JSStr);<br>    <span class="hljs-comment">// 3.3 将提取出来的样式字符串,做进一步的处理</span><br>    const newJS = r1[<span class="hljs-number">0</span>].<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;script&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;&lt;/script&gt;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br><br>    <span class="hljs-comment">// 3.4将提取出来的css样式,写入到index.css文件中</span><br>    fs.writeFile(path.join(__dirname, <span class="hljs-string">&#x27;./index.js&#x27;</span>), newJS, err =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式失败&#x27;</span> + err.message);<br>        &#125;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入CSS样式成功!&#x27;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>步骤5-自定义resolveHTML方法</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 5. 处理html文件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveHTML</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>    <span class="hljs-comment">// 5.1使用字符串的replace方法, 把内嵌的 &lt; style &gt; 和 &lt; script &gt; 标签, 替换为外联的 &lt; link &gt; 划和 &lt; script &gt; 标签</span><br>    const newHTML = htmlStr<br>        .<span class="hljs-built_in">replace</span>(regStyle, <span class="hljs-string">&#x27;&lt;lick rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;</span>)<br>        .<span class="hljs-built_in">replace</span>(regScript, <span class="hljs-string">&#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;</span>)<br>    <span class="hljs-comment">// 5.2将替换完成之后的html代码,写入到index.html文件中</span><br>    fs.writeFile(path.join(__dirname, <span class="hljs-string">&#x27;./index.html&#x27;</span>), newHTML, err =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入失败&#x27;</span>+err.message);<br>        &#125;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>案例的两个注意点</p>
<p> 1 fs.writeFile()方法只能用来创建文件，不能用来创建路径<br> 2 重复调用fs.writeFile()写入同一个文件，新写入的内容会覆盖之前的旧内容</p>
</li>
</ol>
<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>1、什么是http模块</p>
<pre><code class="hljs">回顾：什么是客户端、什么是服务器？
在网络节点中，负责消费资源的电脑，叫做客户端；
负责对外提供网络资源的电脑，叫做服务器；

http模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer()方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。

注意：如果要希望使用http模块创建Web服务器，则需要先导入它：

            const http=require(&#39;http&#39;);
</code></pre>
<p>2、进一步理解http模块的作用</p>
<pre><code class="hljs">服务器和普通的区别在于，服务器上安装了Web服务器软件，例如：IIS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器

在Node.js中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能手写一个服务器软件，从而对外提供web服务
</code></pre>
<p>3、服务器相关的概念</p>
<ol>
<li><p>IP地址</p>
<p> IP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。如果把‘个人电脑’比作‘一台电脑’，那么‘IP地址’就相当于‘电话号码’，只有在知道对方IP的前提下，才能与对应的电脑之间进行数据通信</p>
<p> IP地址的格式：通常用‘点分十进制’表示成(a,b,c,d)的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如：用点分十进制表示IP地址(192.168.1.1)</p>
<p> 注意：</p>
<pre><code class="hljs"> 1 互联网中每台Web服务器，都有自己的IP地址，例如：大家可以在Windows的终端中运行ping www.baidu.com命令，即可查看百度服务器的IP地址
 
 2 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当做一台服务器进行访问了 
</code></pre>
</li>
<li><p>域名和域名服务器</p>
<p> 尽管IP地址能够唯一地址标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名(Domain Name)地址</p>
<p> IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS,Domain name server)的电脑中，使用者只需要通过好记得域名访问对应得服务器即可，对应得转换工作由域名服务器实现，因此，域名服务器就是提供IP地址和域名之间得转换服务的服务器</p>
<p> 注意：</p>
<pre><code class="hljs"> 1 单纯使用IP地址，互联网中的电脑也能正常工作，但是有了域名后的加持，能让互联网的世界变得更加方便
 2 在开发测试期间，127.0.0.1对应域名是localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别
</code></pre>
</li>
<li><p>端口号</p>
<p> 计算机中的端口号，就好像是现实生活中的门牌号，通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中</p>
<p> 同样的道理，在一台电脑中，可以运行成百上千个web服务器</p>
<p> 注意：</p>
<pre><code class="hljs"> 1 每个端口号不能同时被多个web服务器占用
 2 在实际应用中，URL中的80端口可以被省略
</code></pre>
</li>
</ol>
<p>4、创建最基本的web服务器</p>
<ol>
<li><p>创建web服务器的基本步骤</p>
<ol>
<li>导入http模块</li>
<li>创建web服务器实例</li>
<li>为服务器实例绑定request事件，监听客户端的请求</li>
<li>启动服务器</li>
</ol>
</li>
<li><p>步骤1 - 导入http模块</p>
<p> 如果希望在自己的电脑上创建一个web服务器，从而对外提供web服务，则需要导入模块：</p>
</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const http</span>=require(<span class="hljs-string">&#x27;http&#x27;</span>);<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><p>步骤2 - 创建web服务器实例</p>
<p> 调用http.createServer()方法，即可快速创建一个web服务器实例：</p>
</li>
</ol>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-keyword">server</span>=http.createServer()<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><p>步骤3 - 为服务器实例绑定request事件</p>
<p> 为服务器实例绑定request事件，即可监听客户端发送过来的网络请求：</p>
</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>使用服务器实例的 .<span class="hljs-literal">on</span>()方法，为服务器绑定一个request事件<br>server.<span class="hljs-literal">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>    <span class="hljs-regexp">//</span>只要有客户端来请求我们自己的服务器，就会触发request事件，从而调用这个事件处理函数<br>    console.log(<span class="hljs-string">&#x27;Someone visit our web server.&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><p>步骤4 - 启动服务器</p>
<p> 调用服务器实例的.listen()方法，即可启动当前的web服务器实例;</p>
</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//调用<span class="hljs-keyword">server</span>.<span class="hljs-keyword">listen</span>(端口号，cb回调)方法，即可启动web服务器<br><span class="hljs-keyword">server</span>.<span class="hljs-keyword">listen</span>(<span class="hljs-number">80</span>,()=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;http server running at http://127.0.0.1&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><p>req请求对象</p>
<p> 只要服务器接收到了客户端的请求,就会调用server.on()为服务器绑定的request事件处理函数.如果想在事件处理函数中,访问与客户端相关的数据或属性,可以使用如下的方式;</p>
</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,(req)=&gt;&#123;<br>    <span class="hljs-comment">//req是请求对象,它包含了与客户端相关的数据和属性,例如:</span><br>    <span class="hljs-comment">//req.url是客户端请求的URL地址</span><br>    <span class="hljs-comment">//req.method是客户端的method请求类型</span><br>    <span class="hljs-keyword">const</span> str=<span class="hljs-string">&#x27;Your request url is <span class="hljs-subst">$&#123;req.url&#125;</span>,and request method is <span class="hljs-subst">$&#123;req.method&#125;</span>&#x27;</span><br>    console.log(str);<br>&#125;)<br></code></pre></td></tr></table></figure>
<ol start="4">
<li><p>res响应对象</p>
<p> 在服务器的request事件处理函数中,如果想访问与服务器相关的数据或属性,可以使用如下的方式:</p>
</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//res是响应对象,它包含了与服务器相关的数据和属性,例如:</span><br>    <span class="hljs-comment">//要发送到客户端的字符串</span><br>    <span class="hljs-keyword">const</span> str=<span class="hljs-string">&#x27;Your request url is <span class="hljs-subst">$&#123;req.url&#125;</span>,and request method is <span class="hljs-subst">$&#123;req.method&#125;</span>&#x27;</span>;<br>    <span class="hljs-comment">//res.end()方法的作用;</span><br>    <span class="hljs-comment">//向客户端发送指定的内容,并结束这次请求的处理过程</span><br>    res.end(str)<br>&#125;)<br></code></pre></td></tr></table></figure>
<ol start="5">
<li><p>解决中文乱码问题</p>
<p> 当调用res.end()方法,向客户端发送中文内容的时候,会出现乱码问题,此时,需要手动设置内容的编码格式:</p>
</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,(req,res)=&gt;&#123;<br>    <span class="hljs-comment">//发送的内容包含中文</span><br>    <span class="hljs-keyword">const</span> str=<span class="hljs-string">&#x27;您请求的url地址是<span class="hljs-subst">$&#123;req.url&#125;</span>,请求的method类型是<span class="hljs-subst">$&#123;req.method&#125;</span>&#x27;</span><br>    <span class="hljs-comment">//为了防止中文显示乱码的问题,需要设置响应头Content - Type 的值为text/html;charset=utf-8</span><br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>);<br>    <span class="hljs-comment">//把包含中文的内容,响应给客户端</span><br>    res.end(str);<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>5、根据不同的url响应不同的html内容</p>
<ol>
<li><p>核心实现步骤</p>
<ol>
<li>获取请求的url地址</li>
<li>设置默认的响应内容为404 Not found</li>
<li>判断用户请求的是否为&#x2F;或index.html首页</li>
<li>判断用户请求的是否为&#x2F;about.html关于页面</li>
<li>设置Content-Type响应头,防止中文乱码</li>
<li>使用res.end()把内容响应给客户端</li>
</ol>
</li>
<li><p>动态响应内容</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">server<span class="hljs-selector-class">.on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-built_in">function</span>(req,res)&#123;<br>    const url=req<span class="hljs-selector-class">.url</span>               <span class="hljs-comment">//1. 获取请求的url地址</span><br>let <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span>;<span class="hljs-comment">//2. 设置默认的响应内容为404 Not found</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(url===<span class="hljs-string">&#x27;/&#x27;</span>||url===<span class="hljs-string">&#x27;/index.html&#x27;</span>)</span></span>&#123;<br>    <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span>;            <span class="hljs-comment">//3. 判断用户请求的是否为/或index.html首页</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(url===<span class="hljs-string">&#x27;/about.html&#x27;</span>)&#123;<br>    <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span>;        <span class="hljs-comment">// 4. 判断用户请求的是否为/about.html关于页面</span><br>&#125;<br>   <br>res<span class="hljs-selector-class">.setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>)<span class="hljs-comment">//5. 设置Content-Type响应头,防止中文乱码</span><br>res<span class="hljs-selector-class">.end</span>(<span class="hljs-attribute">content</span>);<span class="hljs-comment">//6. 使用res.end()把内容响应给客户端</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<p>6、案例 - 实现clock时钟的web服务器</p>
</li>
<li><p>核心思路</p>
<p> 把文件的实际存放路径，作为每个资源的请求url地址</p>
</li>
<li><p>实现步骤</p>
<ol>
<li>导入需要的模块</li>
<li>创建基本的web服务器</li>
<li>将资源的请求url地址映射为文件的存放路径</li>
<li>读取文件内容并响应给客户端</li>
<li>优化资源的请求路径</li>
</ol>
</li>
<li><p>步骤1 - 导入需要的模块(具体看05.clock时钟web服务器.js文件)</p>
</li>
<li><p>步骤2 - 创建基本的web服务器(具体看05.clock时钟web服务器.js文件)</p>
</li>
<li><p>步骤3 - 将资源的请求url地址映射为文件的存放路径(具体看05.clock时钟web服务器.js文件)</p>
</li>
<li><p>步骤四 - 读取文件的内容并响应给客户端(具体看05.clock时钟web服务器.js文件)</p>
</li>
<li><p>步骤5 - 优化资源的请求路径</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>将<span class="hljs-number">3.2</span>的实现方式，改为如下代码<br><span class="hljs-regexp">//</span><span class="hljs-number">5.1</span>预定义空白的文件存放路径<br>let fpath=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">if</span>(url===<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-number">5.2</span>如果请求的路径是否为/,则手动指定文件的存放路径<br>    fpath=path.join(__dirname,<span class="hljs-string">&#x27;./clock/indexmhtml&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-number">5.3</span>如果请求的路径不为/ ，则动态拼接文件的存放路径<br>    fpath=path.join(__dirname,<span class="hljs-string">&#x27;./clock&#x27;</span>,url);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="模块化的基本概念"><a href="#模块化的基本概念" class="headerlink" title="模块化的基本概念"></a>模块化的基本概念</h2><p>1、什么是模块化</p>
<pre><code class="hljs">模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块时可组合，分解和更换的单元
</code></pre>
<ol>
<li><p>现实生活中的模块化</p>
<p> 霸王游戏机</p>
</li>
<li><p>编程领域中的模块化</p>
<p> 编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块</p>
<p> 把代码进行模块化拆分的好处：</p>
<pre><code class="hljs"> 1. 提高了代码的复用性
 2. 提高了代码的可维护性
 3. 可以实现按需加载
</code></pre>
</li>
</ol>
<p>2、模块化规范</p>
<pre><code class="hljs">模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。

例如：
    使用什么样的语法格式来引用模块
    在模块中使用什么样的语法格式向外暴露成员

模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。
</code></pre>
<h2 id="Node-js中的模块化"><a href="#Node-js中的模块化" class="headerlink" title="Node.js中的模块化"></a>Node.js中的模块化</h2><p>1、Node.js中模块化的分类</p>
<pre><code class="hljs">Node.js中根据模块来源不同，将模块分为了3大类，分别是：

内置模块(内置模块是由Node.js官方提供的，例如fs、path、http等)

自定义模块(用户创建的每个js文件，都是自定义模块)

第三方模块(由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载)
</code></pre>
<p>2、加载模块</p>
<pre><code class="hljs">使用强大的require()方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：

    const custom=require(&#39;./custom.js&#39;);

注意：使用require()方法加载其它模块时，会执行被加载模块中的代码
</code></pre>
<p>3、Node.js中的模块作用域</p>
<ol>
<li><p>什么是模块作用域</p>
<p> 和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</p>
</li>
<li><p>模块作用域的好处</p>
<p> 防止全局变量污染的问题</p>
</li>
</ol>
<p>4、向外共享模块作用域中的成员</p>
<ol>
<li><p>module对象</p>
<p> 在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息，打印如下：</p>
</li>
<li><p>module.exports对象</p>
<p> 在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。</p>
<p> 外界用require()方法导入自定义模块时，得到的就是module.exports所指向的对象</p>
</li>
<li><p>共享成员时的注意点</p>
<p> 使用reuire()方法导入模块时，导入的结果，永远以module.exports指向的对象为准</p>
</li>
<li><p>exports对象</p>
<p> 由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node提供了exports对象。默认情况下，exports和module.exports指向同一个对象，最终共享的结果，还是以module.exports指向的对象为准</p>
</li>
<li><p>exports和module.exporets的使用误区</p>
<p> 时刻谨记，require()模块时，得到的永远是module.exports指向的对象</p>
<p> 注意：为了防止混乱，建议大家不要在同一个模块中同时使用exports和module.exports</p>
</li>
</ol>
<p>5、Node.js中的模块化规范</p>
<pre><code class="hljs">Node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖

CommonJS规定：

    1.每个模块内部，module变量代表当前模块。

    2. module变量是一个对象，它的exports属性(即module.exports)是对外的接口

    3. 加载某个模块，其实是加载该模块的module.exports属性，require()方法用于加载模块 
</code></pre>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/node/">#node</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/17/ES6/" title="ES6">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ES6</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
